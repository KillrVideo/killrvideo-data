{
  "video_id": "lNIrj9VuBQ0",
  "title": "DS201.15 Read Repair  | Foundations of Apache Cassandra",
  "description": "#DataStaxAcademy #DS201\nDS201.15 READ REPAIR\nIn this unit, you will learn about read repair. Read repair is one of the mechanisms that ensures that data in your Apache Cassandra cluster stays in sync.\n\nLEARN FOR FREE at https://academy.datastax.com -- access all the FREE complete courses, tutorials, and hands-on exercises.\n\nASK QUESTIONS at https://community.datastax.com -- where experts from DataStax & the Apache Cassandra community share their expertise everyday.",
  "published_at": "2020-08-11T01:32:32Z",
  "thumbnail": "https://i.ytimg.com/vi/lNIrj9VuBQ0/maxresdefault.jpg",
  "channel_title": "DataStax Developers",
  "channel_id": "UCAIQY251avaMv7bBv5PCo-A",
  "tags": [
    "cassandra",
    "datastax",
    "tutorial",
    "apache_cassandra"
  ],
  "url": "https://www.youtube.com/watch?v=lNIrj9VuBQ0",
  "transcript": {
    "available": true,
    "language": "Chinese",
    "language_code": "zh",
    "is_generated": false,
    "text": "DS201.15: 读修复(read repair) 现在让我们来探索一下修复(repair)功能 随着时间的推移\n节点间的数据可能会变得彼此不同步 这是因为网络故障、节点掉线、磁盘损坏等等 当向你的Apache Cassandra数据库发送请求时 当网络分区(network partition)的情况出现时\n你必须在一致性级别和可用性之间做选择 这就要说回CAP理论了 使用Apache Cassandra 你可以在节点保持高度一致和\n节点保持高可用性之间进行调节 当网络分区问题出现 你是想要让客户端等待\n直到系统恢复一致性 还是你想要将现有的最好回复\n先返回给客户端 选择可用性意味着在网络分区期间 对于实际应该的数值\n副本数据之间有可能出现分歧 让我们来仔细了解一下 当一致性级别为ALL时\n读操作一般会遇到什么情况 这是一个存有数据的集群 这时一个请求被发送到了这个集群 左边的这个节点将作为协调节点(coordinator) 这个请求的一致性级别为ALL 这是你可以要求的最高的一致性级别 右边的三个节点存储着这条数据的副本数据 协调节点会将收到的请求转发给三个节点 这个例子中 反应最快的节点是下方的那个 所以协调节点就找下方的这个节点\n要它实际储存的数据 对于其他的副本节点 协调节点只要数据的摘要(digest)\n或被称为校验和(checksum) 而不是整条数据 这是一种优化 下方的节点返回了数据副本 其他的节点则基于自己的数据副本\n返回了校验和的数值 协调节点将从下方节点返回的\n数据副本变为校验和 然后比较三个校验和是否相同 如果相同 协调节点就会将数据返回给客户端 现在让我们来考虑一个类似的情景\n但这次三个校验和并不相同 同样的 一个请求发送给了节点\n这次还是左边的节点作为协调节点 一致性级别还是ALL 意味着协调节点必须验证\n所有的副本数据都是一致的 协调节点将请求转发给所有的节点 然后注意到校验和并不一致 某些数据过时了 下面的节点返回了副本数据 其他节点则返回了校验和 协调节点先得到了副本数据的校验和 然后和之前一样 比较了所有的校验和 发现有些问题 协调节点要负责将最新的数据\n同步到所有的副本节点 回想一下 每条数据都有一个时间戳对吧 协调节点可以通过时间戳来判断\n哪个节点的数据是最新的 在这个例子中 下方节点返回的\n副本数据的时间戳是135 协调节点还从另两个副本节点\n请求他们的副本数据 注意 右边的节点的时间戳最晚 是159 上边和右边的节点返回了他们的副本数据 除了最右边节点的副本数据外\n协调节点丢弃了其他的副本数据 协调节点向数据过时的节点\n发送了最新数据的副本 同时也将结果返回给客户端 很显然的 将请求的一致性级别设为ALL\n是在牺牲时间换取当下数据的100%正确 根据你的情况 你可能会发现\n用低一些的一致性级别也可以 这意味着大多数时候\n你得到的返回数据都是正确的 当你的请求的一致性级别小于ALL Apache Cassandra仍然会以概率的方式执行读修复 这个概率是可以通过dclocal_read_repair_chance\n这个参数手动配置的 它的默认值是有10%的机会被修复 然而 当Apache Cassandra在这种情况下\n执行读修复的时候 这个修复是异步的 也就是说 客户端可能会得到过时的数据 不过为了以后会返回同样结果集的更多请求 Apache Cassandra会在这之后\n立即将这条数据更新同步 你可以用nodetool来运行一个全面的修复 但是根据你需要修复的数据量 全面修复可能很快会\n将你的整个集群拖入泥潭 将全面修复看做最后的防线吧 如果你有一个节点宕机很长时间 你可能需要修复那个节点 没有数据被读取的节点\n也可能会从时不时的数据更新中获益 现在是时候来通过练习试试修复功能了",
    "segments": [
      {
        "start": 0.0,
        "duration": 5.322,
        "text": "DS201.15: 读修复(read repair)"
      },
      {
        "start": 5.322,
        "duration": 3.933,
        "text": "现在让我们来探索一下修复(repair)功能"
      },
      {
        "start": 9.255,
        "duration": 3.017,
        "text": "随着时间的推移\n节点间的数据可能会变得彼此不同步"
      },
      {
        "start": 12.272,
        "duration": 5.098,
        "text": "这是因为网络故障、节点掉线、磁盘损坏等等"
      },
      {
        "start": 17.37,
        "duration": 2.986,
        "text": "当向你的Apache Cassandra数据库发送请求时"
      },
      {
        "start": 20.356,
        "duration": 5.788,
        "text": "当网络分区(network partition)的情况出现时\n你必须在一致性级别和可用性之间做选择"
      },
      {
        "start": 26.144,
        "duration": 2.457,
        "text": "这就要说回CAP理论了"
      },
      {
        "start": 28.601,
        "duration": 1.579,
        "text": "使用Apache Cassandra"
      },
      {
        "start": 30.18,
        "duration": 5.996,
        "text": "你可以在节点保持高度一致和\n节点保持高可用性之间进行调节"
      },
      {
        "start": 36.176,
        "duration": 2.542,
        "text": "当网络分区问题出现"
      },
      {
        "start": 38.718,
        "duration": 4.893,
        "text": "你是想要让客户端等待\n直到系统恢复一致性"
      },
      {
        "start": 43.611,
        "duration": 3.59,
        "text": "还是你想要将现有的最好回复\n先返回给客户端"
      },
      {
        "start": 47.201,
        "duration": 2.227,
        "text": "选择可用性意味着在网络分区期间"
      },
      {
        "start": 49.428,
        "duration": 6.168,
        "text": "对于实际应该的数值\n副本数据之间有可能出现分歧"
      },
      {
        "start": 55.596,
        "duration": 2.112,
        "text": "让我们来仔细了解一下"
      },
      {
        "start": 57.708,
        "duration": 3.677,
        "text": "当一致性级别为ALL时\n读操作一般会遇到什么情况"
      },
      {
        "start": 61.385,
        "duration": 2.064,
        "text": "这是一个存有数据的集群"
      },
      {
        "start": 63.449,
        "duration": 2.069,
        "text": "这时一个请求被发送到了这个集群"
      },
      {
        "start": 65.518,
        "duration": 2.71,
        "text": "左边的这个节点将作为协调节点(coordinator)"
      },
      {
        "start": 68.228,
        "duration": 3.463,
        "text": "这个请求的一致性级别为ALL"
      },
      {
        "start": 71.691,
        "duration": 3.258,
        "text": "这是你可以要求的最高的一致性级别"
      },
      {
        "start": 74.949,
        "duration": 3.367,
        "text": "右边的三个节点存储着这条数据的副本数据"
      },
      {
        "start": 78.316,
        "duration": 3.979,
        "text": "协调节点会将收到的请求转发给三个节点"
      },
      {
        "start": 82.295,
        "duration": 3.724,
        "text": "这个例子中 反应最快的节点是下方的那个"
      },
      {
        "start": 86.019,
        "duration": 3.496,
        "text": "所以协调节点就找下方的这个节点\n要它实际储存的数据"
      },
      {
        "start": 89.515,
        "duration": 1.895,
        "text": "对于其他的副本节点"
      },
      {
        "start": 91.41,
        "duration": 2.969,
        "text": "协调节点只要数据的摘要(digest)\n或被称为校验和(checksum)"
      },
      {
        "start": 94.379,
        "duration": 3.036,
        "text": "而不是整条数据"
      },
      {
        "start": 97.415,
        "duration": 1.587,
        "text": "这是一种优化"
      },
      {
        "start": 99.002,
        "duration": 2.32,
        "text": "下方的节点返回了数据副本"
      },
      {
        "start": 101.322,
        "duration": 3.079,
        "text": "其他的节点则基于自己的数据副本\n返回了校验和的数值"
      },
      {
        "start": 104.401,
        "duration": 4.74,
        "text": "协调节点将从下方节点返回的\n数据副本变为校验和"
      },
      {
        "start": 109.141,
        "duration": 3.801,
        "text": "然后比较三个校验和是否相同"
      },
      {
        "start": 112.942,
        "duration": 3.805,
        "text": "如果相同 协调节点就会将数据返回给客户端"
      },
      {
        "start": 117.776,
        "duration": 4.837,
        "text": "现在让我们来考虑一个类似的情景\n但这次三个校验和并不相同"
      },
      {
        "start": 122.613,
        "duration": 5.318,
        "text": "同样的 一个请求发送给了节点\n这次还是左边的节点作为协调节点"
      },
      {
        "start": 127.931,
        "duration": 2.295,
        "text": "一致性级别还是ALL"
      },
      {
        "start": 130.226,
        "duration": 4.478,
        "text": "意味着协调节点必须验证\n所有的副本数据都是一致的"
      },
      {
        "start": 134.704,
        "duration": 3.297,
        "text": "协调节点将请求转发给所有的节点"
      },
      {
        "start": 138.001,
        "duration": 2.592,
        "text": "然后注意到校验和并不一致"
      },
      {
        "start": 140.593,
        "duration": 1.554,
        "text": "某些数据过时了"
      },
      {
        "start": 142.147,
        "duration": 2.505,
        "text": "下面的节点返回了副本数据"
      },
      {
        "start": 144.652,
        "duration": 2.544,
        "text": "其他节点则返回了校验和"
      },
      {
        "start": 147.196,
        "duration": 3.216,
        "text": "协调节点先得到了副本数据的校验和"
      },
      {
        "start": 150.412,
        "duration": 2.437,
        "text": "然后和之前一样 比较了所有的校验和"
      },
      {
        "start": 152.849,
        "duration": 1.967,
        "text": "发现有些问题"
      },
      {
        "start": 154.816,
        "duration": 4.4,
        "text": "协调节点要负责将最新的数据\n同步到所有的副本节点"
      },
      {
        "start": 159.216,
        "duration": 4.058,
        "text": "回想一下 每条数据都有一个时间戳对吧"
      },
      {
        "start": 163.274,
        "duration": 5.653,
        "text": "协调节点可以通过时间戳来判断\n哪个节点的数据是最新的"
      },
      {
        "start": 168.927,
        "duration": 5.609,
        "text": "在这个例子中 下方节点返回的\n副本数据的时间戳是135"
      },
      {
        "start": 174.536,
        "duration": 4.354,
        "text": "协调节点还从另两个副本节点\n请求他们的副本数据"
      },
      {
        "start": 178.89,
        "duration": 4.356,
        "text": "注意 右边的节点的时间戳最晚 是159"
      },
      {
        "start": 183.246,
        "duration": 3.1,
        "text": "上边和右边的节点返回了他们的副本数据"
      },
      {
        "start": 186.346,
        "duration": 2.989,
        "text": "除了最右边节点的副本数据外\n协调节点丢弃了其他的副本数据"
      },
      {
        "start": 189.335,
        "duration": 4.806,
        "text": "协调节点向数据过时的节点\n发送了最新数据的副本"
      },
      {
        "start": 194.141,
        "duration": 4.228,
        "text": "同时也将结果返回给客户端"
      },
      {
        "start": 198.369,
        "duration": 1.361,
        "text": "很显然的"
      },
      {
        "start": 199.73,
        "duration": 7.4,
        "text": "将请求的一致性级别设为ALL\n是在牺牲时间换取当下数据的100%正确"
      },
      {
        "start": 207.13,
        "duration": 1.968,
        "text": "根据你的情况"
      },
      {
        "start": 209.098,
        "duration": 2.962,
        "text": "你可能会发现\n用低一些的一致性级别也可以"
      },
      {
        "start": 212.06,
        "duration": 3.491,
        "text": "这意味着大多数时候\n你得到的返回数据都是正确的"
      },
      {
        "start": 215.551,
        "duration": 4.527,
        "text": "当你的请求的一致性级别小于ALL"
      },
      {
        "start": 220.078,
        "duration": 4.702,
        "text": "Apache Cassandra仍然会以概率的方式执行读修复"
      },
      {
        "start": 224.78,
        "duration": 2.188,
        "text": "这个概率是可以通过dclocal_read_repair_chance\n这个参数手动配置的"
      },
      {
        "start": 226.968,
        "duration": 5.225,
        "text": "它的默认值是有10%的机会被修复"
      },
      {
        "start": 232.193,
        "duration": 5.017,
        "text": "然而 当Apache Cassandra在这种情况下\n执行读修复的时候"
      },
      {
        "start": 237.21,
        "duration": 2.246,
        "text": "这个修复是异步的"
      },
      {
        "start": 239.456,
        "duration": 3.07,
        "text": "也就是说 客户端可能会得到过时的数据"
      },
      {
        "start": 242.526,
        "duration": 3.834,
        "text": "不过为了以后会返回同样结果集的更多请求"
      },
      {
        "start": 246.36,
        "duration": 3.275,
        "text": "Apache Cassandra会在这之后\n立即将这条数据更新同步"
      },
      {
        "start": 249.635,
        "duration": 3.327,
        "text": "你可以用nodetool来运行一个全面的修复"
      },
      {
        "start": 252.962,
        "duration": 4.452,
        "text": "但是根据你需要修复的数据量"
      },
      {
        "start": 257.414,
        "duration": 2.841,
        "text": "全面修复可能很快会\n将你的整个集群拖入泥潭"
      },
      {
        "start": 260.255,
        "duration": 3.051,
        "text": "将全面修复看做最后的防线吧"
      },
      {
        "start": 263.306,
        "duration": 3.084,
        "text": "如果你有一个节点宕机很长时间"
      },
      {
        "start": 266.39,
        "duration": 2.071,
        "text": "你可能需要修复那个节点"
      },
      {
        "start": 268.461,
        "duration": 5.134,
        "text": "没有数据被读取的节点\n也可能会从时不时的数据更新中获益"
      },
      {
        "start": 273.595,
        "duration": 3.653,
        "text": "现在是时候来通过练习试试修复功能了"
      }
    ],
    "error": null,
    "error_type": null
  },
  "collected_at": "2025-12-16T01:55:40.349162+00:00"
}