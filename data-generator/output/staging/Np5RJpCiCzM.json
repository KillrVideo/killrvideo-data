{
  "video_id": "Np5RJpCiCzM",
  "title": "DS201.03 Partitions | Foundations of Apache Cassandra",
  "description": "#DataStaxAcademy #DS201\nDS201.03 PARTITIONS\nPartitions are the most important part of an Apache Cassandra data model. Learn about how Apache Cassandra data is stored in partitions on node in this unit.\n\nLEARN FOR FREE at https://academy.datastax.com -- access all the FREE complete courses, tutorials, and hands-on exercises.\n\nASK QUESTIONS at https://community.datastax.com -- where experts from DataStax & the Apache Cassandra community share their expertise everyday.",
  "published_at": "2020-08-06T03:48:19Z",
  "thumbnail": "https://i.ytimg.com/vi/Np5RJpCiCzM/maxresdefault.jpg",
  "channel_title": "DataStax Developers",
  "channel_id": "UCAIQY251avaMv7bBv5PCo-A",
  "tags": [
    "cassandra",
    "datastax",
    "tutorial",
    "apache_cassandra"
  ],
  "url": "https://www.youtube.com/watch?v=Np5RJpCiCzM",
  "transcript": {
    "available": true,
    "language": "Chinese (China)",
    "language_code": "zh-CN",
    "is_generated": false,
    "text": "DS201.3: 分区(Partitions) Hi 我是Patric Mcfadin 现在让我们来讨论分区 这是Cassandra数据模型中最重要的一部分 所以 请打起精神 如果你要打瞌睡 这个部分可不是打瞌睡的地方  我要确保你掌握这个部分 因为这是Cassandra数据建模成败的关键 我说得太夸张了吗？ 我并不这么觉得 现在让我们从简单的开始 我不想让你因一些复杂情况而感到不堪重负 这是数据库表(Table) 这里的数据库表和你在关系型数据库里看到的差不多 有表的名字、一些列(Column) 还有些转换为列的字段(field) 如user_id或state 这看起来很简单 对吧 我们有和其他数据库类似的主键(Primary Key) 而且同理的 它是用来体现记录的唯一性的 但这里有一些细微的差异 当我们在表格中插入数据时 我们有INTERT...VALUES等等 它们看起来都很熟悉 但在这里 底层的数据模型十分依赖于主键 当我们插入更多数据时 你可以看到它变得非常表格化 因此无论何时 当你查询这个数据时 它就和你在写一个用关系式数据库的应用程序一样 因此当在表格中插入很多数据时 从应用程序的角度来看这和关系型数据库是一模一样的 当你执行SELECT语句时 你会得到一个有行和列的表格 这十分熟悉 感觉很不错对吧 但如果我们想做一些不同的呢？ 在Cassandra数据模型中 我们会针对应用程序进行优化 在这个实例中 也许我们想用数据模型来优化一些东西 例如 如果我们想针对某一个地区进行优化 比如如果我们想针对state（美国的“州”）优化 如果是在关系式数据库中 我们就要使用GROUP BY语句了 GROUP BY语句是十分查询依赖的(query dependent) 且需要依赖节点或服务器来完成接下来的所有操作 这样成本会有一点高 因为这样会用到全表扫描等 这不是最快速获取数据的方法 Cassandra就很不一样了 在Cassandra里我们有“用分区键来将数据进行分类”的概念 在这里 我们将用state这个字段对我们的数据进行分组 因此 如果我们单看每一个分区 它们都会有一个唯一的state 这意味着我们要利用这一点改变我们的数据模型 这里就是我们要考虑我们的应用程序的地方了 我们的查询语句需要用state作为数据的分组逻辑 我们的应用程序也是一样 同时这也帮助我们了解哈希环(ring)的工作效率是怎样的 现在来让我们谈谈哈希环和分区键是如何协同工作的 这是一个很重要的概念 分区键反映了数据会如何在哈希环上被储存 让我们花几秒钟再澄清一下 对数据模型的选择实际上可以极大地影响数据查询的效率 当数据被录入系统中 即当你插入数据时 这些数据会通过一致性哈希算法进行分区 哈希算法会将数据的分区键转化为一个哈希值 之后根据这个哈希值 数据会被存放在环的正确位置上 这也许是你以前从来没仔细想过的 比如当我设计一个数据模型时 我会更多考虑数据的物理布局 确实 你不需要考虑得这么深 但是如果你考虑一下它所带来的影响 你其实是在提前优化你的数据集 比如在查询语句中使用类似物化视图(Materialized View)一类的工具 其实你就是在说：我对这些数据有特定的需求 我要优化我的数据模型 并且也知道它与物理数据模型有关 在当我们有多个分区时 在这里我们有基于state的分区 我们要确保我们的主键 也就是state 插一句 当我们说主键(Primary Key)state时 我们其实在说两个意思 我们其实是在说 state是一条数据中能标识其唯一性的部分 同时我们也将用state来进行分区 主键中的第一部分永远会是分区键(Partition Key) 在现在这个例子中 state作为分区键不足以唯一标识一条数据 在现实情况下 我们会向主键再加一部分（使其足以唯一标识每条数据） 从而确保我们不会覆写记录 如果我将state作为唯一的主键 那每次插入数据时 数据库会只是反复覆写同一条数据 这不是特别的高效 除非你只想在你的数据库中储存大概50条数据\n（译者注：因为美国共有50个州） 在这个例子中 我们引入了id 这足以让这个数据模型中的数据能够被唯一识别 这就是我们所说的聚类键(Clustering Column) 我们会在之后进一步讲解 state在这里是分区键 分区键对于判断你数据在哈希环的位置仍然是十分重要的 当我们讲到哈希环本身时  分区键会很有趣地对应数据在环上的位置 这也是Cassandra的一个特别酷的概念 如果你问我 我觉得这其实是Cassandra的独门秘籍 因为当我将数据加入环中时 我知道它会被放到哪里 如果你有一个1000个节点的哈希环 并且将Texas(美国的德克萨斯州)作为数据输入 你会知道这条数据将被储存在哪儿 这也是一种很有趣的查询数据的方法 因为分区算法(Partitioner)使用一种一致性哈希算法 这意味着无论你何时查询数据 你的数据都会在同一个地方 你不需要再去寻找它 当然 这也是十分快的 这是常数时间(constant time)复杂度算法 用那些计算机科学家的话来说 这是n(1)复杂度的算法 这也意味着当我想要查找包含Texas的数据时 我清楚地知道在这1000个节点的哈希环上 这条数据被储存的具体位置 这就是我所说的独门秘籍 这也是为什么分区键对于Cassandra来说如此重要 那现在让我们在习题中用分区键做些实际的事情吧",
    "segments": [
      {
        "start": 0.261,
        "duration": 6.107,
        "text": "DS201.3: 分区(Partitions)"
      },
      {
        "start": 6.542,
        "duration": 1.581,
        "text": "Hi 我是Patric Mcfadin"
      },
      {
        "start": 8.123,
        "duration": 2.0,
        "text": "现在让我们来讨论分区"
      },
      {
        "start": 10.123,
        "duration": 3.313,
        "text": "这是Cassandra数据模型中最重要的一部分"
      },
      {
        "start": 13.52,
        "duration": 1.562,
        "text": "所以 请打起精神"
      },
      {
        "start": 15.167,
        "duration": 2.696,
        "text": "如果你要打瞌睡 这个部分可不是打瞌睡的地方"
      },
      {
        "start": 17.863,
        "duration": 1.734,
        "text": " 我要确保你掌握这个部分"
      },
      {
        "start": 19.597,
        "duration": 3.578,
        "text": "因为这是Cassandra数据建模成败的关键"
      },
      {
        "start": 23.432,
        "duration": 1.703,
        "text": "我说得太夸张了吗？"
      },
      {
        "start": 25.135,
        "duration": 0.969,
        "text": "我并不这么觉得"
      },
      {
        "start": 26.354,
        "duration": 1.87,
        "text": "现在让我们从简单的开始"
      },
      {
        "start": 28.224,
        "duration": 1.848,
        "text": "我不想让你因一些复杂情况而感到不堪重负"
      },
      {
        "start": 30.209,
        "duration": 1.125,
        "text": "这是数据库表(Table)"
      },
      {
        "start": 31.334,
        "duration": 3.365,
        "text": "这里的数据库表和你在关系型数据库里看到的差不多"
      },
      {
        "start": 34.699,
        "duration": 3.812,
        "text": "有表的名字、一些列(Column)"
      },
      {
        "start": 38.511,
        "duration": 4.566,
        "text": "还有些转换为列的字段(field) 如user_id或state"
      },
      {
        "start": 43.077,
        "duration": 2.25,
        "text": "这看起来很简单 对吧"
      },
      {
        "start": 45.327,
        "duration": 3.062,
        "text": "我们有和其他数据库类似的主键(Primary Key)"
      },
      {
        "start": 48.389,
        "duration": 3.828,
        "text": "而且同理的 它是用来体现记录的唯一性的"
      },
      {
        "start": 52.217,
        "duration": 2.234,
        "text": "但这里有一些细微的差异"
      },
      {
        "start": 54.451,
        "duration": 2.203,
        "text": "当我们在表格中插入数据时"
      },
      {
        "start": 56.654,
        "duration": 3.249,
        "text": "我们有INTERT...VALUES等等"
      },
      {
        "start": 59.903,
        "duration": 2.0,
        "text": "它们看起来都很熟悉"
      },
      {
        "start": 61.903,
        "duration": 5.109,
        "text": "但在这里 底层的数据模型十分依赖于主键"
      },
      {
        "start": 67.012,
        "duration": 3.172,
        "text": "当我们插入更多数据时 你可以看到它变得非常表格化"
      },
      {
        "start": 70.184,
        "duration": 2.266,
        "text": "因此无论何时 当你查询这个数据时"
      },
      {
        "start": 72.45,
        "duration": 4.062,
        "text": "它就和你在写一个用关系式数据库的应用程序一样"
      },
      {
        "start": 76.512,
        "duration": 3.001,
        "text": "因此当在表格中插入很多数据时"
      },
      {
        "start": 79.513,
        "duration": 3.155,
        "text": "从应用程序的角度来看这和关系型数据库是一模一样的"
      },
      {
        "start": 82.668,
        "duration": 3.783,
        "text": "当你执行SELECT语句时 你会得到一个有行和列的表格"
      },
      {
        "start": 86.451,
        "duration": 2.341,
        "text": "这十分熟悉 感觉很不错对吧"
      },
      {
        "start": 88.792,
        "duration": 2.469,
        "text": "但如果我们想做一些不同的呢？"
      },
      {
        "start": 91.261,
        "duration": 2.844,
        "text": "在Cassandra数据模型中"
      },
      {
        "start": 94.105,
        "duration": 2.653,
        "text": "我们会针对应用程序进行优化"
      },
      {
        "start": 96.758,
        "duration": 1.75,
        "text": "在这个实例中"
      },
      {
        "start": 98.508,
        "duration": 3.852,
        "text": "也许我们想用数据模型来优化一些东西"
      },
      {
        "start": 102.438,
        "duration": 1.297,
        "text": "例如"
      },
      {
        "start": 103.86,
        "duration": 3.828,
        "text": "如果我们想针对某一个地区进行优化"
      },
      {
        "start": 107.797,
        "duration": 3.046,
        "text": "比如如果我们想针对state（美国的“州”）优化"
      },
      {
        "start": 111.0,
        "duration": 4.64,
        "text": "如果是在关系式数据库中 我们就要使用GROUP BY语句了"
      },
      {
        "start": 115.64,
        "duration": 3.109,
        "text": "GROUP BY语句是十分查询依赖的(query dependent)"
      },
      {
        "start": 118.749,
        "duration": 5.359,
        "text": "且需要依赖节点或服务器来完成接下来的所有操作"
      },
      {
        "start": 124.108,
        "duration": 1.918,
        "text": "这样成本会有一点高"
      },
      {
        "start": 126.026,
        "duration": 2.828,
        "text": "因为这样会用到全表扫描等"
      },
      {
        "start": 128.854,
        "duration": 2.533,
        "text": "这不是最快速获取数据的方法"
      },
      {
        "start": 131.387,
        "duration": 2.088,
        "text": "Cassandra就很不一样了"
      },
      {
        "start": 133.475,
        "duration": 6.545,
        "text": "在Cassandra里我们有“用分区键来将数据进行分类”的概念"
      },
      {
        "start": 140.02,
        "duration": 4.765,
        "text": "在这里 我们将用state这个字段对我们的数据进行分组"
      },
      {
        "start": 144.785,
        "duration": 2.848,
        "text": "因此 如果我们单看每一个分区"
      },
      {
        "start": 147.633,
        "duration": 2.0,
        "text": "它们都会有一个唯一的state"
      },
      {
        "start": 149.633,
        "duration": 3.679,
        "text": "这意味着我们要利用这一点改变我们的数据模型"
      },
      {
        "start": 153.312,
        "duration": 2.25,
        "text": "这里就是我们要考虑我们的应用程序的地方了"
      },
      {
        "start": 155.562,
        "duration": 5.03,
        "text": "我们的查询语句需要用state作为数据的分组逻辑"
      },
      {
        "start": 160.592,
        "duration": 1.783,
        "text": "我们的应用程序也是一样"
      },
      {
        "start": 162.375,
        "duration": 3.834,
        "text": "同时这也帮助我们了解哈希环(ring)的工作效率是怎样的"
      },
      {
        "start": 166.209,
        "duration": 3.708,
        "text": "现在来让我们谈谈哈希环和分区键是如何协同工作的"
      },
      {
        "start": 169.917,
        "duration": 2.271,
        "text": "这是一个很重要的概念"
      },
      {
        "start": 172.188,
        "duration": 4.604,
        "text": "分区键反映了数据会如何在哈希环上被储存"
      },
      {
        "start": 177.0,
        "duration": 1.438,
        "text": "让我们花几秒钟再澄清一下"
      },
      {
        "start": 178.651,
        "duration": 6.579,
        "text": "对数据模型的选择实际上可以极大地影响数据查询的效率"
      },
      {
        "start": 185.23,
        "duration": 4.389,
        "text": "当数据被录入系统中 即当你插入数据时"
      },
      {
        "start": 189.9,
        "duration": 3.656,
        "text": "这些数据会通过一致性哈希算法进行分区"
      },
      {
        "start": 193.556,
        "duration": 3.859,
        "text": "哈希算法会将数据的分区键转化为一个哈希值"
      },
      {
        "start": 197.415,
        "duration": 5.188,
        "text": "之后根据这个哈希值 数据会被存放在环的正确位置上"
      },
      {
        "start": 202.603,
        "duration": 4.041,
        "text": "这也许是你以前从来没仔细想过的"
      },
      {
        "start": 206.644,
        "duration": 4.027,
        "text": "比如当我设计一个数据模型时 我会更多考虑数据的物理布局"
      },
      {
        "start": 210.671,
        "duration": 2.732,
        "text": "确实 你不需要考虑得这么深"
      },
      {
        "start": 213.403,
        "duration": 2.421,
        "text": "但是如果你考虑一下它所带来的影响"
      },
      {
        "start": 215.824,
        "duration": 2.483,
        "text": "你其实是在提前优化你的数据集"
      },
      {
        "start": 218.307,
        "duration": 3.343,
        "text": "比如在查询语句中使用类似物化视图(Materialized View)一类的工具"
      },
      {
        "start": 221.65,
        "duration": 3.079,
        "text": "其实你就是在说：我对这些数据有特定的需求"
      },
      {
        "start": 224.729,
        "duration": 2.0,
        "text": "我要优化我的数据模型"
      },
      {
        "start": 226.729,
        "duration": 3.188,
        "text": "并且也知道它与物理数据模型有关"
      },
      {
        "start": 229.917,
        "duration": 3.024,
        "text": "在当我们有多个分区时"
      },
      {
        "start": 232.941,
        "duration": 2.547,
        "text": "在这里我们有基于state的分区"
      },
      {
        "start": 235.488,
        "duration": 4.512,
        "text": "我们要确保我们的主键 也就是state"
      },
      {
        "start": 240.0,
        "duration": 3.0,
        "text": "插一句 当我们说主键(Primary Key)state时 我们其实在说两个意思"
      },
      {
        "start": 243.0,
        "duration": 3.834,
        "text": "我们其实是在说 state是一条数据中能标识其唯一性的部分"
      },
      {
        "start": 246.834,
        "duration": 2.737,
        "text": "同时我们也将用state来进行分区"
      },
      {
        "start": 249.571,
        "duration": 4.632,
        "text": "主键中的第一部分永远会是分区键(Partition Key)"
      },
      {
        "start": 254.203,
        "duration": 4.163,
        "text": "在现在这个例子中 state作为分区键不足以唯一标识一条数据"
      },
      {
        "start": 258.366,
        "duration": 1.518,
        "text": "在现实情况下"
      },
      {
        "start": 259.884,
        "duration": 2.934,
        "text": "我们会向主键再加一部分（使其足以唯一标识每条数据）"
      },
      {
        "start": 262.818,
        "duration": 2.0,
        "text": "从而确保我们不会覆写记录"
      },
      {
        "start": 264.818,
        "duration": 2.5,
        "text": "如果我将state作为唯一的主键"
      },
      {
        "start": 267.318,
        "duration": 3.546,
        "text": "那每次插入数据时 数据库会只是反复覆写同一条数据"
      },
      {
        "start": 270.864,
        "duration": 0.938,
        "text": "这不是特别的高效"
      },
      {
        "start": 271.802,
        "duration": 3.515,
        "text": "除非你只想在你的数据库中储存大概50条数据\n（译者注：因为美国共有50个州）"
      },
      {
        "start": 275.317,
        "duration": 2.109,
        "text": "在这个例子中 我们引入了id"
      },
      {
        "start": 277.426,
        "duration": 3.562,
        "text": "这足以让这个数据模型中的数据能够被唯一识别"
      },
      {
        "start": 280.988,
        "duration": 2.615,
        "text": "这就是我们所说的聚类键(Clustering Column)"
      },
      {
        "start": 283.603,
        "duration": 1.538,
        "text": "我们会在之后进一步讲解"
      },
      {
        "start": 285.141,
        "duration": 2.281,
        "text": "state在这里是分区键"
      },
      {
        "start": 287.422,
        "duration": 4.078,
        "text": "分区键对于判断你数据在哈希环的位置仍然是十分重要的"
      },
      {
        "start": 291.5,
        "duration": 2.62,
        "text": "当我们讲到哈希环本身时 "
      },
      {
        "start": 294.12,
        "duration": 5.547,
        "text": "分区键会很有趣地对应数据在环上的位置"
      },
      {
        "start": 299.667,
        "duration": 4.093,
        "text": "这也是Cassandra的一个特别酷的概念"
      },
      {
        "start": 303.76,
        "duration": 2.422,
        "text": "如果你问我 我觉得这其实是Cassandra的独门秘籍"
      },
      {
        "start": 306.182,
        "duration": 3.969,
        "text": "因为当我将数据加入环中时 我知道它会被放到哪里"
      },
      {
        "start": 310.151,
        "duration": 2.0,
        "text": "如果你有一个1000个节点的哈希环"
      },
      {
        "start": 312.151,
        "duration": 2.203,
        "text": "并且将Texas(美国的德克萨斯州)作为数据输入"
      },
      {
        "start": 314.354,
        "duration": 1.641,
        "text": "你会知道这条数据将被储存在哪儿"
      },
      {
        "start": 315.995,
        "duration": 3.472,
        "text": "这也是一种很有趣的查询数据的方法"
      },
      {
        "start": 319.467,
        "duration": 3.422,
        "text": "因为分区算法(Partitioner)使用一种一致性哈希算法"
      },
      {
        "start": 322.889,
        "duration": 2.286,
        "text": "这意味着无论你何时查询数据"
      },
      {
        "start": 325.175,
        "duration": 2.268,
        "text": "你的数据都会在同一个地方"
      },
      {
        "start": 327.443,
        "duration": 1.641,
        "text": "你不需要再去寻找它"
      },
      {
        "start": 329.084,
        "duration": 1.15,
        "text": "当然 这也是十分快的"
      },
      {
        "start": 330.234,
        "duration": 1.803,
        "text": "这是常数时间(constant time)复杂度算法"
      },
      {
        "start": 332.037,
        "duration": 2.672,
        "text": "用那些计算机科学家的话来说 这是n(1)复杂度的算法"
      },
      {
        "start": 334.709,
        "duration": 2.76,
        "text": "这也意味着当我想要查找包含Texas的数据时"
      },
      {
        "start": 337.469,
        "duration": 3.147,
        "text": "我清楚地知道在这1000个节点的哈希环上 这条数据被储存的具体位置"
      },
      {
        "start": 340.616,
        "duration": 2.025,
        "text": "这就是我所说的独门秘籍"
      },
      {
        "start": 342.641,
        "duration": 3.014,
        "text": "这也是为什么分区键对于Cassandra来说如此重要"
      },
      {
        "start": 345.655,
        "duration": 3.764,
        "text": "那现在让我们在习题中用分区键做些实际的事情吧"
      }
    ],
    "error": null,
    "error_type": null
  },
  "collected_at": "2025-12-16T02:09:47.672776+00:00"
}