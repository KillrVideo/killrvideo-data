{
  "video_id": "IAvU1G_yokE",
  "title": "DS201.16 Node Sync | Foundations of Apache Cassandra",
  "description": "#DataStaxAcademy #DS201\nDS201.16 NODE SYNC\nThis unit will teach you about Node Sync, an awesome new feature in DataStax Enterprise 6. It continually runs in the background checking for out of date replicas and sync them with the most up to date version.\n\nLEARN FOR FREE at https://academy.datastax.com -- access all the FREE complete courses, tutorials, and hands-on exercises.\n\nASK QUESTIONS at https://community.datastax.com -- where experts from DataStax & the Apache Cassandra community share their expertise everyday.",
  "published_at": "2020-08-11T01:57:45Z",
  "thumbnail": "https://i.ytimg.com/vi/IAvU1G_yokE/maxresdefault.jpg",
  "channel_title": "DataStax Developers",
  "channel_id": "UCAIQY251avaMv7bBv5PCo-A",
  "tags": [
    "cassandra",
    "datastax",
    "tutorial",
    "apache_cassandra"
  ],
  "url": "https://www.youtube.com/watch?v=IAvU1G_yokE",
  "transcript": {
    "available": true,
    "language": "Chinese",
    "language_code": "zh",
    "is_generated": false,
    "text": "DS201.16: NodeSync（节点同步） 你可以通过nodetool启动集群的全面修复 然而全面修复经常将集群拖入泥淖\n而且还会有损集群的性能 因为其他的节点必须和\n正在被修复的节点验证副本数据 根据数据过时的严重程度 这也给你的网络造成了额外的负载 作为一个管理员 你还得确保在gc_grace_seconds的\n时间范围内运行全面修复 从而防止僵尸数据的产生 管理这些是痛苦的 DataStax Enterprise 6有一个叫做\nNodeSync（节点同步）的新功能 简单说 它持续地在后台运行 它查找过时的数据\n并将它们与最新的数据同步 这比全面修复要好 因为它引起的集群额外负载\n就像是涓涓细流 持续但量小 而不像是全面修复那样集中发生的大量负载\n给集群带来很大负担 这个功能在DataStax Enterprise中是自动启用的 但是你必须再为每一个表启动这个功能 所有的节点都在后台运行NodeSync\n互相检查彼此的副本数据从而确保保持同步 在这里你可以看到我们是如何在\nCREATE TABLE语句中启用NodeSync的 如果你好奇的话 我们来谈谈NodeSync的原理细节 NodeSync将节点的本地令牌区间(token range)\n组合成令牌区间段(segment) NodeSync会将同一个段的令牌区间\n作为一个小组进行修复 它还会追踪修复结果 比如成功或失败 在修复过程中记录自身的进度 每次NodeSync完成了一个令牌区间段的修复 它会在一个我们称为save point的\n数据结构中记录修复结果 还记得gc_grace_seconds吗 它的默认值是10天 NodeSync会制定令牌区间段的修复优先级 从而保证每个令牌区间段都在\ngc_grace_seconds这个过期时限之前被修复 从此你不必再因为对集群使用全面修复而感到担忧 NodeSync理想的令牌区间段的大小\n大概在200MB 如果你想的话 你也可以调整这个数值 但200MB这个默认值是不错的 如果一个令牌区间段中的单个数据分区\n已经大于200MB了 那么这个令牌区间段的大小\n就会扩大到这个数据分区的大小 想要决定哪些令牌分区\n会组合成一个令牌区间段 NodeSync会先将整个令牌区间\n看做一个令牌区间段 然后再不断拆分\n直到令牌区间段达到目标的大小 不过相比假设一个还说得过去的\n数据模型的数据分布是不错的 NodeSync把对一个令牌区间段的修复\n看作是一个原子单位(atomic unit) 这意味着整个令牌区间段必须\n作为一个整体全部修复成功 才能算这次修复成功完成了 NodeSync在一个叫nodesync_status的表中\n记录每次修复的状态 如果一个节点在某个令牌区间段修复的时候\n发生离线故障 出于安全机制 NodeSync会将\n这个令牌区间段整体看做“没被修复” NodeSync在一个叫nodesync_status的表中\n记录每次修复的状态 对于令牌区间段的修复\n可能有这么几种结果 这个表的最上面是最成功的修复结果\n下面的修复结果的效果依次递减 full_in_sync的意思是所有的副本数据都被检查过了\n而且他们现在都是同步的了 full_repaired的意思是所有副本节点都回复了\n并且已经做了必要的修复 partial_in_sync的意思是部分副本节点回复了\n并且回复的副本数据都已经都同步了 partial_repaired的意思是部分副本节点回复了\n并且回复的副本数据中已经做了必要的修复 uncompleted的意思是只有一个能联系到的副本\n所以无法进行同步工作 failed就是指同步过程失败了\n在日志中你可以找到更多信息 修复令牌区间段的过程是非常好理解的 NodeSync的修复过程和读修复(read repair)\n以及全面修复的过程是一样的 也就是读取所有的副本数据并确保他们是同步的 如果不同步 就根据时间戳较晚的副本节点\n更新时间戳较早的副本节点的数据",
    "segments": [
      {
        "start": 0.0,
        "duration": 5.405,
        "text": "DS201.16: NodeSync（节点同步）"
      },
      {
        "start": 6.553,
        "duration": 3.149,
        "text": "你可以通过nodetool启动集群的全面修复"
      },
      {
        "start": 9.702,
        "duration": 6.315,
        "text": "然而全面修复经常将集群拖入泥淖\n而且还会有损集群的性能"
      },
      {
        "start": 16.017,
        "duration": 3.752,
        "text": "因为其他的节点必须和\n正在被修复的节点验证副本数据"
      },
      {
        "start": 19.769,
        "duration": 2.757,
        "text": "根据数据过时的严重程度"
      },
      {
        "start": 22.526,
        "duration": 3.811,
        "text": "这也给你的网络造成了额外的负载"
      },
      {
        "start": 26.337,
        "duration": 1.304,
        "text": "作为一个管理员"
      },
      {
        "start": 27.641,
        "duration": 3.751,
        "text": "你还得确保在gc_grace_seconds的\n时间范围内运行全面修复"
      },
      {
        "start": 31.392,
        "duration": 1.858,
        "text": "从而防止僵尸数据的产生"
      },
      {
        "start": 33.25,
        "duration": 1.928,
        "text": "管理这些是痛苦的"
      },
      {
        "start": 35.178,
        "duration": 3.879,
        "text": "DataStax Enterprise 6有一个叫做\nNodeSync（节点同步）的新功能"
      },
      {
        "start": 39.057,
        "duration": 2.833,
        "text": "简单说 它持续地在后台运行"
      },
      {
        "start": 41.89,
        "duration": 4.699,
        "text": "它查找过时的数据\n并将它们与最新的数据同步"
      },
      {
        "start": 46.589,
        "duration": 1.744,
        "text": "这比全面修复要好"
      },
      {
        "start": 48.333,
        "duration": 2.191,
        "text": "因为它引起的集群额外负载\n就像是涓涓细流 持续但量小"
      },
      {
        "start": 50.524,
        "duration": 3.841,
        "text": "而不像是全面修复那样集中发生的大量负载\n给集群带来很大负担"
      },
      {
        "start": 54.365,
        "duration": 3.751,
        "text": "这个功能在DataStax Enterprise中是自动启用的"
      },
      {
        "start": 58.116,
        "duration": 3.159,
        "text": "但是你必须再为每一个表启动这个功能"
      },
      {
        "start": 61.275,
        "duration": 6.875,
        "text": "所有的节点都在后台运行NodeSync\n互相检查彼此的副本数据从而确保保持同步"
      },
      {
        "start": 68.15,
        "duration": 4.413,
        "text": "在这里你可以看到我们是如何在\nCREATE TABLE语句中启用NodeSync的"
      },
      {
        "start": 72.563,
        "duration": 2.155,
        "text": "如果你好奇的话"
      },
      {
        "start": 74.718,
        "duration": 3.053,
        "text": "我们来谈谈NodeSync的原理细节"
      },
      {
        "start": 77.771,
        "duration": 4.301,
        "text": "NodeSync将节点的本地令牌区间(token range)\n组合成令牌区间段(segment)"
      },
      {
        "start": 82.072,
        "duration": 2.72,
        "text": "NodeSync会将同一个段的令牌区间\n作为一个小组进行修复"
      },
      {
        "start": 84.792,
        "duration": 3.145,
        "text": "它还会追踪修复结果 比如成功或失败"
      },
      {
        "start": 87.937,
        "duration": 2.501,
        "text": "在修复过程中记录自身的进度"
      },
      {
        "start": 90.438,
        "duration": 2.935,
        "text": "每次NodeSync完成了一个令牌区间段的修复"
      },
      {
        "start": 93.373,
        "duration": 4.069,
        "text": "它会在一个我们称为save point的\n数据结构中记录修复结果"
      },
      {
        "start": 97.442,
        "duration": 2.231,
        "text": "还记得gc_grace_seconds吗"
      },
      {
        "start": 99.673,
        "duration": 2.238,
        "text": "它的默认值是10天"
      },
      {
        "start": 101.911,
        "duration": 2.89,
        "text": "NodeSync会制定令牌区间段的修复优先级"
      },
      {
        "start": 104.801,
        "duration": 2.983,
        "text": "从而保证每个令牌区间段都在\ngc_grace_seconds这个过期时限之前被修复"
      },
      {
        "start": 107.784,
        "duration": 3.909,
        "text": "从此你不必再因为对集群使用全面修复而感到担忧"
      },
      {
        "start": 111.693,
        "duration": 5.602,
        "text": "NodeSync理想的令牌区间段的大小\n大概在200MB"
      },
      {
        "start": 117.295,
        "duration": 1.694,
        "text": "如果你想的话 你也可以调整这个数值"
      },
      {
        "start": 118.989,
        "duration": 2.649,
        "text": "但200MB这个默认值是不错的"
      },
      {
        "start": 122.18,
        "duration": 4.215,
        "text": "如果一个令牌区间段中的单个数据分区\n已经大于200MB了"
      },
      {
        "start": 126.395,
        "duration": 4.581,
        "text": "那么这个令牌区间段的大小\n就会扩大到这个数据分区的大小"
      },
      {
        "start": 131.363,
        "duration": 3.227,
        "text": "想要决定哪些令牌分区\n会组合成一个令牌区间段"
      },
      {
        "start": 134.59,
        "duration": 3.892,
        "text": "NodeSync会先将整个令牌区间\n看做一个令牌区间段"
      },
      {
        "start": 138.482,
        "duration": 4.137,
        "text": "然后再不断拆分\n直到令牌区间段达到目标的大小"
      },
      {
        "start": 142.619,
        "duration": 4.53,
        "text": "不过相比假设一个还说得过去的\n数据模型的数据分布是不错的"
      },
      {
        "start": 147.149,
        "duration": 3.646,
        "text": "NodeSync把对一个令牌区间段的修复\n看作是一个原子单位(atomic unit)"
      },
      {
        "start": 150.795,
        "duration": 3.827,
        "text": "这意味着整个令牌区间段必须\n作为一个整体全部修复成功"
      },
      {
        "start": 154.622,
        "duration": 2.419,
        "text": "才能算这次修复成功完成了"
      },
      {
        "start": 157.041,
        "duration": 5.587,
        "text": "NodeSync在一个叫nodesync_status的表中\n记录每次修复的状态"
      },
      {
        "start": 162.628,
        "duration": 2.655,
        "text": "如果一个节点在某个令牌区间段修复的时候\n发生离线故障"
      },
      {
        "start": 165.283,
        "duration": 4.367,
        "text": "出于安全机制 NodeSync会将\n这个令牌区间段整体看做“没被修复”"
      },
      {
        "start": 169.65,
        "duration": 5.74,
        "text": "NodeSync在一个叫nodesync_status的表中\n记录每次修复的状态"
      },
      {
        "start": 176.667,
        "duration": 3.099,
        "text": "对于令牌区间段的修复\n可能有这么几种结果"
      },
      {
        "start": 179.766,
        "duration": 6.351,
        "text": "这个表的最上面是最成功的修复结果\n下面的修复结果的效果依次递减"
      },
      {
        "start": 186.117,
        "duration": 4.682,
        "text": "full_in_sync的意思是所有的副本数据都被检查过了\n而且他们现在都是同步的了"
      },
      {
        "start": 190.799,
        "duration": 4.892,
        "text": "full_repaired的意思是所有副本节点都回复了\n并且已经做了必要的修复"
      },
      {
        "start": 195.691,
        "duration": 6.077,
        "text": "partial_in_sync的意思是部分副本节点回复了\n并且回复的副本数据都已经都同步了"
      },
      {
        "start": 201.768,
        "duration": 5.053,
        "text": "partial_repaired的意思是部分副本节点回复了\n并且回复的副本数据中已经做了必要的修复"
      },
      {
        "start": 206.821,
        "duration": 5.69,
        "text": "uncompleted的意思是只有一个能联系到的副本\n所以无法进行同步工作"
      },
      {
        "start": 212.511,
        "duration": 5.776,
        "text": "failed就是指同步过程失败了\n在日志中你可以找到更多信息"
      },
      {
        "start": 218.287,
        "duration": 2.842,
        "text": "修复令牌区间段的过程是非常好理解的"
      },
      {
        "start": 221.129,
        "duration": 6.526,
        "text": "NodeSync的修复过程和读修复(read repair)\n以及全面修复的过程是一样的"
      },
      {
        "start": 227.655,
        "duration": 4.41,
        "text": "也就是读取所有的副本数据并确保他们是同步的"
      },
      {
        "start": 232.065,
        "duration": 1.598,
        "text": "如果不同步"
      },
      {
        "start": 233.663,
        "duration": 4.813,
        "text": "就根据时间戳较晚的副本节点\n更新时间戳较早的副本节点的数据"
      }
    ],
    "error": null,
    "error_type": null
  },
  "collected_at": "2025-12-16T01:54:39.838136+00:00"
}