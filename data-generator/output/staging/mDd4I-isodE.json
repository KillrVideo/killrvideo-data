{
  "video_id": "mDd4I-isodE",
  "title": "DS201.17 Write Path | Foundations of Apache Cassandra",
  "description": "#DataStaxAcademy #DS201\nDS201.17 WRITE PATH\nApache Cassandra ingests data at a high rate of speed because of the way data is stored when it comes into a particular node. In this unit, we will learn about the write path.\n\nLEARN FOR FREE at https://academy.datastax.com -- access all the FREE complete courses, tutorials, and hands-on exercises.\n\nASK QUESTIONS at https://community.datastax.com -- where experts from DataStax & the Apache Cassandra community share their expertise everyday.",
  "published_at": "2020-08-11T02:05:03Z",
  "thumbnail": "https://i.ytimg.com/vi/mDd4I-isodE/maxresdefault.jpg",
  "channel_title": "DataStax Developers",
  "channel_id": "UCAIQY251avaMv7bBv5PCo-A",
  "tags": [
    "cassandra",
    "datastax",
    "tutorial",
    "apache_cassandra"
  ],
  "url": "https://www.youtube.com/watch?v=mDd4I-isodE",
  "transcript": {
    "available": true,
    "language": "Chinese",
    "language_code": "zh",
    "is_generated": false,
    "text": "DS201.17: 写入路径(Write Path) 我是Jamie King 你可能已经听说了Cassandra可以高速注入数据 这可以归功于当数据被传入节点时\nCassandra可以在节点层面很高性能地储存这条数据 我们称之为 写入路径 大多数数据库系统的数据存储方法\n是独家信息 是不为人所知的 相比之下  Apache Cassandra是一本大大开放的书 我们在这节视频中可以看到 它是如何运行的\n以及为什么它能有如此快的处理速度 这是我们在前面的视频中看到过的\n一个单独的节点 这时一个写入请求来了\n我们要这个节点上存储一些用户数据 让我们仔细研究一下这个节点\n具体看看这个过程是如何发生的 在上方我们有RAM（内存） 在下方我们有硬盘存储空间 还是刚才的那个写入 让我们先快速看一下这些数据 1是分区键 用户的名字是Dev Awesome 这个用户住在Texas（美国德州）的\nHouston（休斯顿）市 顺便说一下 在这个例子中\n所有的用户都住在Texas 这些数据将根据城市被分组排序 当这条记录进入Apache Cassandra数据库 实际上Apache Cassandra会将其\n同时写入内存和硬盘 我们称在内存中的数据结构为MemTable 而硬盘中的数据结构被称为Commit Log MemTable和Commit Log的最重要的差异在于 MemTable的数据是根据分区键(partition key)\n和聚类列(clustering column)来排序的 而Commit Log的数据则是\n根据数据写入的顺序排序的 每条新来的数据就被添加到Commit Log的最末尾 在这个时候  Cassandra会通知客户端\n这个写入是成功的  无需进一步操作 就是这么简单 Apache Cassandra先在内存和硬盘中写入记录 然后通知客户端说 嘿  我收到你的数据了  发下一条吧 让我们看看另一个数据插入的过程 这个用户的名字是ComeTo DSE \nDSE是DataStax Enterprise的缩写 如我之前所说 这个用户也住在Texas\n不过是住在Dallas（达拉斯市） Apache Cassandra会将这条记录\n写入Commit Log的结尾 再次提醒  Commit Log是根据写入顺序排序的 我们就只是在硬盘上简单地\n附加附加再附加新的数据 而在MemTable中 Apache Cassandra会根据聚类列\n将这条数据插入合适的地方 对于Dallas 在字母表上d在（Houston的）h前面 或从字典序来看  Dallas也比Houston更靠前大概10倍 然后像之前一样\nCassandra会通知客户端说 嘿  任务搞定了 然后又来了一条记录 我想请你在此处暂停视频然后想想 这条数据在MemTable和Commit Log\n分别会排在何处 现在停一下视频 稍微想一下\n我们会在这儿等你 Lone Node住在Snyder（斯奈德市） Snyder排在Dallas和Houston之后 所以这条记录会排在MemTable的最后一行 对于Commit Log\n这条记录会去Commit Log的末尾 我们向来会在Commit Log的末尾附加新的记录 让我们谈谈这两个数据结构的作用吧 由于MemTable是存储在内存的 且Apache Cassandra是按照聚类列对其进行排序的 Apache Cassandra可以在之后从中\n读取并向用户返回数据 就像你在使用CQL的SELECT语句时\n就会看到这样做返回的结果 使用Commit Log的目的在于 嘿 这个节点可能崩溃了 烧掉了 挂掉了\n或者可能发生了其它任何事情 为了让这个节点恢复到其崩溃之前的状态 Apache Cassandra会从硬盘中读取Commit Log 并重新执行之前的数据变更 这样我们就不会受到影响\n这个节点也可以继续正常工作 所以在内存中的数据结构是为了读取数据 而Commit Log则是在节点故障需要恢复时\n用于恢复节点状态 这里又来了一条写入数据 这次是IgotUr Data\n（意为“我收到了你的数据”） 谢谢Apache Cassandra 他们住在Austin（奥斯汀）\n所以这条记录会去MemTable最靠前的位置 在Commit Log中\n这条记录会去最靠后的位置 像往常一样附于Commit Log的末尾 我知道这个示意图让人看起来好像\nCassandra在内存中到处复制数值 但实际上如果你更熟悉这些术语 你会知道内部发生的只是\n一些引用和指针的改变 这并不是很耗费资源 重点是如果我们需要读取数据 我们就可以读取数据 拿回我们的数据 并且先按照分区键再按照聚类列\n进行分类排序 在我们的例子中\n我们的所有记录的分区键都是Texas 而聚类列则是城市 又来了一条写入数据  Always Onomnom 他们住在Dallas\n所以他们会去找同住在Dallas的好兄弟 在Commit Log中\n他们还是会被附于其末尾的位置 虽然听起来有点儿无聊 但是这其实非常酷 因为Apache Cassandra可以在数据写入时对其快速处理 这个简单的过程让用户\n除了写入以外无需考虑太多 最后一条记录\n住在El Paso（埃尔帕索）的Lone Star 在MemTable中正确的位置插入这条记录 再将其附于Commit Log的末尾 太好了 我们都搞定了 此时 虽然图中右方还有一大块蓝色的空间 我们假定现在MemTable已经满了 由于有多种用于调节MemTable数据存储量的参数\n并且内存空间是种有限的资源 Cassandra需要把MemTable\n从内存中拿出来放入硬盘中 所以Cassandra所做的就是\n把MemTable中的数据从内存中flush到硬盘 到这个时候  我们就不再需要Commit Log 现在所有在硬盘中的数据都是持久的了 因为Apache Cassandra把它们都写入硬盘了 这个新的数据结构叫做SSTable SSTable是Sorted String Table（有序的字符串表）的简写 就像SSTable的字面意思\n这个表先根据分区键再根据聚类列进行排序 划重点 这个数据结构是不可变的(immutable) 当我们将MemTable写入硬盘并创建一个SSTable Apache Cassandra将不会再对这些数据\n做出增删改等任何你能想象到的改变 这些数据就是这样 不能再变了 你可能会想：等等 如果SSTable是不可变的 我怎么做增删改一类的事情呢 别担心  我们会在后面的课程中解答这个问题 目前我们建议将Commit Log和SSTable\n存储在不同的硬盘上 为什么？因为我们总在Commit Log的末尾\n附加附加再附加数据 当我们想要注入数据时 如果同一块硬盘同时还在忙于对数据的\n读取 写入 改变 flush 压实 像我们在另一节课里提到的那样 那你的节点也许不能发挥其性能 所以记得把Commit Log放在别的机械硬盘上 尤其是如果你还在用旋转型磁盘(spinner) 为了演示下面的内容  我们先忽略Commit Log 知道Commit Log还在后台工作中就可以了 让我们插入一些数据 一条条数据正在被插入 要记得  我们是根据城市给数据排序的 Cassandra会根据城市的值排列并存储所有的数据 噢看呐 我们的MemTable又满了 让我们也清空它 这样就有了两个SSTable 它们都是我们整个表格数据集的一部分 在关于读取路径(read path)的那一节视频中 我们将会探索Cassandra是如何在读取时合并这些数据 好的  又到了练习时间了 去研究一下写入路径吧  我们将会在另一个视频中揭晓答案",
    "segments": [
      {
        "start": 1.14,
        "duration": 5.06,
        "text": "DS201.17: 写入路径(Write Path)"
      },
      {
        "start": 6.54,
        "duration": 1.62,
        "text": "我是Jamie King"
      },
      {
        "start": 8.16,
        "duration": 4.02,
        "text": "你可能已经听说了Cassandra可以高速注入数据"
      },
      {
        "start": 12.18,
        "duration": 4.82,
        "text": "这可以归功于当数据被传入节点时\nCassandra可以在节点层面很高性能地储存这条数据"
      },
      {
        "start": 17.0,
        "duration": 2.38,
        "text": "我们称之为 写入路径"
      },
      {
        "start": 19.38,
        "duration": 5.229,
        "text": "大多数数据库系统的数据存储方法\n是独家信息 是不为人所知的"
      },
      {
        "start": 24.609,
        "duration": 2.767,
        "text": "相比之下  Apache Cassandra是一本大大开放的书"
      },
      {
        "start": 27.376,
        "duration": 1.385,
        "text": "我们在这节视频中可以看到"
      },
      {
        "start": 28.761,
        "duration": 3.179,
        "text": "它是如何运行的\n以及为什么它能有如此快的处理速度"
      },
      {
        "start": 31.94,
        "duration": 3.56,
        "text": "这是我们在前面的视频中看到过的\n一个单独的节点"
      },
      {
        "start": 35.5,
        "duration": 4.48,
        "text": "这时一个写入请求来了\n我们要这个节点上存储一些用户数据"
      },
      {
        "start": 39.98,
        "duration": 3.484,
        "text": "让我们仔细研究一下这个节点\n具体看看这个过程是如何发生的"
      },
      {
        "start": 43.464,
        "duration": 2.356,
        "text": "在上方我们有RAM（内存）"
      },
      {
        "start": 45.82,
        "duration": 2.36,
        "text": "在下方我们有硬盘存储空间"
      },
      {
        "start": 48.18,
        "duration": 1.5,
        "text": "还是刚才的那个写入"
      },
      {
        "start": 49.68,
        "duration": 2.0,
        "text": "让我们先快速看一下这些数据"
      },
      {
        "start": 51.68,
        "duration": 3.88,
        "text": "1是分区键 用户的名字是Dev Awesome"
      },
      {
        "start": 55.56,
        "duration": 4.03,
        "text": "这个用户住在Texas（美国德州）的\nHouston（休斯顿）市"
      },
      {
        "start": 59.59,
        "duration": 4.09,
        "text": "顺便说一下 在这个例子中\n所有的用户都住在Texas"
      },
      {
        "start": 63.68,
        "duration": 2.32,
        "text": "这些数据将根据城市被分组排序"
      },
      {
        "start": 66.0,
        "duration": 2.842,
        "text": "当这条记录进入Apache Cassandra数据库"
      },
      {
        "start": 68.842,
        "duration": 5.035,
        "text": "实际上Apache Cassandra会将其\n同时写入内存和硬盘"
      },
      {
        "start": 73.877,
        "duration": 3.152,
        "text": "我们称在内存中的数据结构为MemTable"
      },
      {
        "start": 77.029,
        "duration": 3.263,
        "text": "而硬盘中的数据结构被称为Commit Log"
      },
      {
        "start": 80.292,
        "duration": 3.388,
        "text": "MemTable和Commit Log的最重要的差异在于"
      },
      {
        "start": 83.68,
        "duration": 4.78,
        "text": "MemTable的数据是根据分区键(partition key)\n和聚类列(clustering column)来排序的"
      },
      {
        "start": 88.46,
        "duration": 2.954,
        "text": "而Commit Log的数据则是\n根据数据写入的顺序排序的"
      },
      {
        "start": 91.414,
        "duration": 3.195,
        "text": "每条新来的数据就被添加到Commit Log的最末尾"
      },
      {
        "start": 94.609,
        "duration": 5.85,
        "text": "在这个时候  Cassandra会通知客户端\n这个写入是成功的  无需进一步操作"
      },
      {
        "start": 100.459,
        "duration": 1.501,
        "text": "就是这么简单"
      },
      {
        "start": 101.96,
        "duration": 3.86,
        "text": "Apache Cassandra先在内存和硬盘中写入记录"
      },
      {
        "start": 105.82,
        "duration": 1.9,
        "text": "然后通知客户端说"
      },
      {
        "start": 107.72,
        "duration": 2.724,
        "text": "嘿  我收到你的数据了  发下一条吧"
      },
      {
        "start": 110.444,
        "duration": 2.173,
        "text": "让我们看看另一个数据插入的过程"
      },
      {
        "start": 112.617,
        "duration": 5.183,
        "text": "这个用户的名字是ComeTo DSE \nDSE是DataStax Enterprise的缩写"
      },
      {
        "start": 117.8,
        "duration": 4.335,
        "text": "如我之前所说 这个用户也住在Texas\n不过是住在Dallas（达拉斯市）"
      },
      {
        "start": 122.135,
        "duration": 3.745,
        "text": "Apache Cassandra会将这条记录\n写入Commit Log的结尾"
      },
      {
        "start": 125.88,
        "duration": 1.74,
        "text": "再次提醒  Commit Log是根据写入顺序排序的"
      },
      {
        "start": 127.62,
        "duration": 4.24,
        "text": "我们就只是在硬盘上简单地\n附加附加再附加新的数据"
      },
      {
        "start": 131.86,
        "duration": 1.22,
        "text": "而在MemTable中"
      },
      {
        "start": 133.08,
        "duration": 6.12,
        "text": "Apache Cassandra会根据聚类列\n将这条数据插入合适的地方"
      },
      {
        "start": 139.2,
        "duration": 4.8,
        "text": "对于Dallas 在字母表上d在（Houston的）h前面"
      },
      {
        "start": 144.0,
        "duration": 3.146,
        "text": "或从字典序来看  Dallas也比Houston更靠前大概10倍"
      },
      {
        "start": 147.146,
        "duration": 2.034,
        "text": "然后像之前一样\nCassandra会通知客户端说"
      },
      {
        "start": 149.18,
        "duration": 1.7,
        "text": "嘿  任务搞定了"
      },
      {
        "start": 150.88,
        "duration": 1.82,
        "text": "然后又来了一条记录"
      },
      {
        "start": 153.188,
        "duration": 3.004,
        "text": "我想请你在此处暂停视频然后想想"
      },
      {
        "start": 156.192,
        "duration": 4.683,
        "text": "这条数据在MemTable和Commit Log\n分别会排在何处"
      },
      {
        "start": 160.875,
        "duration": 3.205,
        "text": "现在停一下视频 稍微想一下\n我们会在这儿等你"
      },
      {
        "start": 164.48,
        "duration": 2.48,
        "text": "Lone Node住在Snyder（斯奈德市）"
      },
      {
        "start": 166.96,
        "duration": 2.76,
        "text": "Snyder排在Dallas和Houston之后"
      },
      {
        "start": 169.72,
        "duration": 2.6,
        "text": "所以这条记录会排在MemTable的最后一行"
      },
      {
        "start": 172.32,
        "duration": 3.513,
        "text": "对于Commit Log\n这条记录会去Commit Log的末尾"
      },
      {
        "start": 175.833,
        "duration": 2.581,
        "text": "我们向来会在Commit Log的末尾附加新的记录"
      },
      {
        "start": 178.414,
        "duration": 3.17,
        "text": "让我们谈谈这两个数据结构的作用吧"
      },
      {
        "start": 181.584,
        "duration": 1.776,
        "text": "由于MemTable是存储在内存的"
      },
      {
        "start": 183.36,
        "duration": 3.1,
        "text": "且Apache Cassandra是按照聚类列对其进行排序的"
      },
      {
        "start": 186.46,
        "duration": 3.78,
        "text": "Apache Cassandra可以在之后从中\n读取并向用户返回数据"
      },
      {
        "start": 190.24,
        "duration": 2.9,
        "text": "就像你在使用CQL的SELECT语句时\n就会看到这样做返回的结果"
      },
      {
        "start": 193.14,
        "duration": 1.66,
        "text": "使用Commit Log的目的在于"
      },
      {
        "start": 194.8,
        "duration": 3.92,
        "text": "嘿 这个节点可能崩溃了 烧掉了 挂掉了\n或者可能发生了其它任何事情"
      },
      {
        "start": 198.72,
        "duration": 4.14,
        "text": "为了让这个节点恢复到其崩溃之前的状态"
      },
      {
        "start": 202.86,
        "duration": 2.92,
        "text": "Apache Cassandra会从硬盘中读取Commit Log"
      },
      {
        "start": 205.78,
        "duration": 2.14,
        "text": "并重新执行之前的数据变更"
      },
      {
        "start": 207.92,
        "duration": 2.88,
        "text": "这样我们就不会受到影响\n这个节点也可以继续正常工作"
      },
      {
        "start": 210.8,
        "duration": 2.46,
        "text": "所以在内存中的数据结构是为了读取数据"
      },
      {
        "start": 213.28,
        "duration": 5.22,
        "text": "而Commit Log则是在节点故障需要恢复时\n用于恢复节点状态"
      },
      {
        "start": 218.5,
        "duration": 1.92,
        "text": "这里又来了一条写入数据"
      },
      {
        "start": 220.42,
        "duration": 1.8,
        "text": "这次是IgotUr Data\n（意为“我收到了你的数据”）"
      },
      {
        "start": 222.24,
        "duration": 2.0,
        "text": "谢谢Apache Cassandra"
      },
      {
        "start": 224.24,
        "duration": 2.94,
        "text": "他们住在Austin（奥斯汀）\n所以这条记录会去MemTable最靠前的位置"
      },
      {
        "start": 227.18,
        "duration": 3.5,
        "text": "在Commit Log中\n这条记录会去最靠后的位置"
      },
      {
        "start": 230.68,
        "duration": 2.48,
        "text": "像往常一样附于Commit Log的末尾"
      },
      {
        "start": 233.16,
        "duration": 5.38,
        "text": "我知道这个示意图让人看起来好像\nCassandra在内存中到处复制数值"
      },
      {
        "start": 238.54,
        "duration": 2.393,
        "text": "但实际上如果你更熟悉这些术语"
      },
      {
        "start": 240.933,
        "duration": 2.405,
        "text": "你会知道内部发生的只是\n一些引用和指针的改变"
      },
      {
        "start": 243.338,
        "duration": 1.24,
        "text": "这并不是很耗费资源"
      },
      {
        "start": 244.578,
        "duration": 2.202,
        "text": "重点是如果我们需要读取数据"
      },
      {
        "start": 246.78,
        "duration": 1.94,
        "text": "我们就可以读取数据 拿回我们的数据"
      },
      {
        "start": 248.72,
        "duration": 3.16,
        "text": "并且先按照分区键再按照聚类列\n进行分类排序"
      },
      {
        "start": 251.88,
        "duration": 3.743,
        "text": "在我们的例子中\n我们的所有记录的分区键都是Texas"
      },
      {
        "start": 255.623,
        "duration": 1.937,
        "text": "而聚类列则是城市"
      },
      {
        "start": 257.56,
        "duration": 4.377,
        "text": "又来了一条写入数据  Always Onomnom"
      },
      {
        "start": 261.937,
        "duration": 3.803,
        "text": "他们住在Dallas\n所以他们会去找同住在Dallas的好兄弟"
      },
      {
        "start": 265.74,
        "duration": 4.26,
        "text": "在Commit Log中\n他们还是会被附于其末尾的位置"
      },
      {
        "start": 270.0,
        "duration": 2.607,
        "text": "虽然听起来有点儿无聊 但是这其实非常酷"
      },
      {
        "start": 272.607,
        "duration": 2.779,
        "text": "因为Apache Cassandra可以在数据写入时对其快速处理"
      },
      {
        "start": 275.386,
        "duration": 2.189,
        "text": "这个简单的过程让用户\n除了写入以外无需考虑太多"
      },
      {
        "start": 277.575,
        "duration": 4.245,
        "text": "最后一条记录\n住在El Paso（埃尔帕索）的Lone Star"
      },
      {
        "start": 281.82,
        "duration": 3.029,
        "text": "在MemTable中正确的位置插入这条记录"
      },
      {
        "start": 284.849,
        "duration": 1.871,
        "text": "再将其附于Commit Log的末尾"
      },
      {
        "start": 286.72,
        "duration": 1.76,
        "text": "太好了 我们都搞定了"
      },
      {
        "start": 288.48,
        "duration": 4.04,
        "text": "此时 虽然图中右方还有一大块蓝色的空间"
      },
      {
        "start": 292.52,
        "duration": 2.26,
        "text": "我们假定现在MemTable已经满了"
      },
      {
        "start": 294.78,
        "duration": 5.436,
        "text": "由于有多种用于调节MemTable数据存储量的参数\n并且内存空间是种有限的资源"
      },
      {
        "start": 300.216,
        "duration": 4.924,
        "text": "Cassandra需要把MemTable\n从内存中拿出来放入硬盘中"
      },
      {
        "start": 305.14,
        "duration": 4.68,
        "text": "所以Cassandra所做的就是\n把MemTable中的数据从内存中flush到硬盘"
      },
      {
        "start": 309.82,
        "duration": 3.132,
        "text": "到这个时候  我们就不再需要Commit Log"
      },
      {
        "start": 312.952,
        "duration": 2.248,
        "text": "现在所有在硬盘中的数据都是持久的了"
      },
      {
        "start": 315.2,
        "duration": 2.62,
        "text": "因为Apache Cassandra把它们都写入硬盘了"
      },
      {
        "start": 317.82,
        "duration": 2.94,
        "text": "这个新的数据结构叫做SSTable"
      },
      {
        "start": 320.76,
        "duration": 2.42,
        "text": "SSTable是Sorted String Table（有序的字符串表）的简写"
      },
      {
        "start": 323.18,
        "duration": 5.94,
        "text": "就像SSTable的字面意思\n这个表先根据分区键再根据聚类列进行排序"
      },
      {
        "start": 329.12,
        "duration": 3.86,
        "text": "划重点 这个数据结构是不可变的(immutable)"
      },
      {
        "start": 333.0,
        "duration": 4.415,
        "text": "当我们将MemTable写入硬盘并创建一个SSTable"
      },
      {
        "start": 337.415,
        "duration": 4.585,
        "text": "Apache Cassandra将不会再对这些数据\n做出增删改等任何你能想象到的改变"
      },
      {
        "start": 342.0,
        "duration": 2.38,
        "text": "这些数据就是这样 不能再变了"
      },
      {
        "start": 344.38,
        "duration": 3.26,
        "text": "你可能会想：等等 如果SSTable是不可变的"
      },
      {
        "start": 347.64,
        "duration": 3.68,
        "text": "我怎么做增删改一类的事情呢"
      },
      {
        "start": 351.32,
        "duration": 2.44,
        "text": "别担心  我们会在后面的课程中解答这个问题"
      },
      {
        "start": 354.0,
        "duration": 7.726,
        "text": "目前我们建议将Commit Log和SSTable\n存储在不同的硬盘上"
      },
      {
        "start": 361.726,
        "duration": 3.814,
        "text": "为什么？因为我们总在Commit Log的末尾\n附加附加再附加数据"
      },
      {
        "start": 365.54,
        "duration": 1.24,
        "text": "当我们想要注入数据时"
      },
      {
        "start": 366.78,
        "duration": 4.38,
        "text": "如果同一块硬盘同时还在忙于对数据的\n读取 写入 改变 flush 压实"
      },
      {
        "start": 371.16,
        "duration": 2.14,
        "text": "像我们在另一节课里提到的那样"
      },
      {
        "start": 373.3,
        "duration": 3.011,
        "text": "那你的节点也许不能发挥其性能"
      },
      {
        "start": 376.311,
        "duration": 2.869,
        "text": "所以记得把Commit Log放在别的机械硬盘上"
      },
      {
        "start": 379.18,
        "duration": 2.68,
        "text": "尤其是如果你还在用旋转型磁盘(spinner)"
      },
      {
        "start": 381.86,
        "duration": 4.02,
        "text": "为了演示下面的内容  我们先忽略Commit Log"
      },
      {
        "start": 385.88,
        "duration": 3.64,
        "text": "知道Commit Log还在后台工作中就可以了"
      },
      {
        "start": 389.52,
        "duration": 2.72,
        "text": "让我们插入一些数据"
      },
      {
        "start": 392.24,
        "duration": 2.14,
        "text": "一条条数据正在被插入"
      },
      {
        "start": 394.38,
        "duration": 2.698,
        "text": "要记得  我们是根据城市给数据排序的"
      },
      {
        "start": 397.078,
        "duration": 3.602,
        "text": "Cassandra会根据城市的值排列并存储所有的数据"
      },
      {
        "start": 400.68,
        "duration": 2.46,
        "text": "噢看呐 我们的MemTable又满了"
      },
      {
        "start": 403.14,
        "duration": 1.94,
        "text": "让我们也清空它"
      },
      {
        "start": 405.08,
        "duration": 2.06,
        "text": "这样就有了两个SSTable"
      },
      {
        "start": 407.16,
        "duration": 3.7,
        "text": "它们都是我们整个表格数据集的一部分"
      },
      {
        "start": 410.86,
        "duration": 1.54,
        "text": "在关于读取路径(read path)的那一节视频中"
      },
      {
        "start": 412.4,
        "duration": 4.2,
        "text": "我们将会探索Cassandra是如何在读取时合并这些数据"
      },
      {
        "start": 416.6,
        "duration": 2.42,
        "text": "好的  又到了练习时间了"
      },
      {
        "start": 419.02,
        "duration": 3.76,
        "text": "去研究一下写入路径吧  我们将会在另一个视频中揭晓答案"
      }
    ],
    "error": null,
    "error_type": null
  },
  "collected_at": "2025-12-16T01:53:39.688549+00:00"
}