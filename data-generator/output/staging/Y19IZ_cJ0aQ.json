{
  "video_id": "Y19IZ_cJ0aQ",
  "title": "DS320.21 Key/Value Pairs: Set Operations | DataStax Enterprise Analytics",
  "description": "#DataStaxAcademy #DS320\nDS320.21 Key/Value Pairs: Set Operations\nIn this course, you will learn how to effectively and efficiently solve analytical problems with Apache Spark™, Apache Cassandra™, and DataStax Enterprise. You will learn about the Spark API, Spark-Cassandra Connector, Spark SQL, Spark Streaming, and crucial performance optimization techniques.  You will also learn the basics of the productive and robust Scala programming language for data analysis and processing in Apache Spark™.\n\nLEARN FOR FREE at https://academy.datastax.com -- access all the FREE complete courses, tutorials, and hands-on exercises.\n\nASK QUESTIONS at https://community.datastax.com -- where experts from DataStax & the Apache Cassandra community share their expertise everyday.",
  "published_at": "2020-08-16T00:29:15Z",
  "thumbnail": "https://i.ytimg.com/vi/Y19IZ_cJ0aQ/maxresdefault.jpg",
  "channel_title": "DataStax Developers",
  "channel_id": "UCAIQY251avaMv7bBv5PCo-A",
  "tags": [
    "cassandra",
    "tutorial",
    "apache_cassandra",
    "performance",
    "datastax"
  ],
  "url": "https://www.youtube.com/watch?v=Y19IZ_cJ0aQ",
  "transcript": {
    "available": true,
    "language": "English (auto-generated)",
    "language_code": "en",
    "is_generated": true,
    "text": "[Music] next we want to do some referential integrity validation now that's not a feature that cassandra supports natively you can have a table that refers to another table that's easy enough to do but the database itself is never going to tell you you're pointing to the wrong thing or you're pointing to something that doesn't exist or anything like that so we'd like to solve that problem here in particular we'd like to know does any of our playlists contain a movie that doesn't really exist let's look at the code for getting that done first we're going to create a playlists rdd easy enough we get all of the playlists by user and we're doing a slightly more sophisticated method here of turning that into a pair rdd by calling key buy and we're picking out the movie id as a uuid to to make that the key likewise with movies we get all of the movies just select the movie id and key buy with that movie id now that's a pair rdd where effectively there is no value but that's fine for us we just want the rdd to contain a complete collection of all of the valid movies now we want the result to contain playlists that don't have a valid join key so this is going to call for a left outer join we're going to left out or join movies onto playlists as you see in that third line of code there the third section of code to keep only those tuples those rows where the second component is not defined that is where there is no valid movie associated with that playlist entry then we'll map those since we have this nice polite pair rdd that contains a collection of the playlist row and the movie row we really only care about the playlist row so we're going to map that and pluck out the playlist row and make that our new result rdd which finally we'll collect and iterate over and print out and we'll show you just one row of that that you'll notice is a cassandra row at that point this is no longer a pair rdd after the map call in the left inner join sequence that stopped being a pair rdd and it's just now a collection of cassandra rows but we've got those rows and we can now say hey here's a playlist entry that points to something that doesn't really exist we can decide what we want to do with that do we want to delete it do we want to flag it do we want to put it in a queue and mention it to the user all decisions the application can make but we've done distributed referential integrity checking with this left outer join now we have the set oriented pair rdd transformations these are union intersection and difference you see those venn diagrams there if you're not familiar with those as set terms those very helpfully illustrate what these three things do they are quite easy to call we'll still show you some code and some examples of useful things we might do with these if you really want to watch these work you can type this code in all of the examples are based on parallelized collection literals so this is stuff you can play with in the spark shell really easily a key based union is going to take those two arrays and it's really easiest to visualize them in terms of the tables the rdds you see down below but it's going to combine them it's going to take anything that's in the first one anything that's in the second one and give us an output rdd that contains all of that and yes duplicates are allowed if you want a key-based intersection it turns out you have to do a little bit of this work on your own this is an important set operation that takes two rdds as input and gives you an output containing the keys that are common to both however unlike a join it doesn't do any sort of collection or aggregation of the values you're still going to get one record in the output rdd per record in the input rdd you don't get you don't get iterables of the values that you saw on the inputs so looking at the slide we see we have to do a little bit of work first we're going to take that rdd a group it by key and join it to be grouped by key that's really what a key based intersection is is a join however at the end we'll flat map the results we'll flat map the values and unroll the collections that the join created for us key based difference also fairly straightforward it takes a second rdd and finds all of the occurrences of those keys in the first rdd and strips them out so you get only keys in the first rdd that didn't happen in the second one and as you can see in the example here k1 k2 k1 and k3 occur in the first rdd the second has k1 k2 and k4 k3 is the only one that escapes the notice of that second rdd and it's what occurs in the output we can actually use that to do a simplified bit of data validation a little while ago we found all the playlists that didn't have valid movies we used a left inner join for that we can actually do that with subtract by key let's take a look at the code first we get the playlists from the database we turn them into a pair rdd based on movie id then we get the movies and we turn them into a pair rdd based on movie id again kind of that silly pair rdd in the movie example uh because there is no value but that's okay that's all we need then we take the playlists and subtract the movies by value collect for each and you're done it's a much simpler way to think of it in terms of a set difference than the inner join logic that we wrote before so you can see that the mere fact of breaking up an rdd into a key value structure exposes all kinds of powerful functionality and a few really useful apis that address very practical use cases that we can apply even to our fictional video hosting website this stuff is super useful and i hope you've gotten a feel for how pair rdds can unlock a lot of the power of spark [Music]",
    "segments": [
      {
        "start": 0.06,
        "duration": 3.45,
        "text": "[Music]"
      },
      {
        "start": 6.16,
        "duration": 2.64,
        "text": "next we want to do some referential"
      },
      {
        "start": 7.52,
        "duration": 2.64,
        "text": "integrity validation"
      },
      {
        "start": 8.8,
        "duration": 4.08,
        "text": "now that's not a feature that cassandra"
      },
      {
        "start": 10.16,
        "duration": 4.639,
        "text": "supports natively you can have a table"
      },
      {
        "start": 12.88,
        "duration": 3.52,
        "text": "that refers to another table that's easy"
      },
      {
        "start": 14.799,
        "duration": 2.56,
        "text": "enough to do but the database itself is"
      },
      {
        "start": 16.4,
        "duration": 2.4,
        "text": "never going to tell you"
      },
      {
        "start": 17.359,
        "duration": 2.401,
        "text": "you're pointing to the wrong thing or"
      },
      {
        "start": 18.8,
        "duration": 2.72,
        "text": "you're pointing to something that"
      },
      {
        "start": 19.76,
        "duration": 3.279,
        "text": "doesn't exist or anything like that so"
      },
      {
        "start": 21.52,
        "duration": 2.96,
        "text": "we'd like to solve that problem here in"
      },
      {
        "start": 23.039,
        "duration": 4.4,
        "text": "particular we'd like to know"
      },
      {
        "start": 24.48,
        "duration": 3.68,
        "text": "does any of our playlists contain a"
      },
      {
        "start": 27.439,
        "duration": 2.881,
        "text": "movie"
      },
      {
        "start": 28.16,
        "duration": 3.439,
        "text": "that doesn't really exist let's look at"
      },
      {
        "start": 30.32,
        "duration": 3.52,
        "text": "the code for getting that done"
      },
      {
        "start": 31.599,
        "duration": 3.361,
        "text": "first we're going to create a playlists"
      },
      {
        "start": 33.84,
        "duration": 3.76,
        "text": "rdd"
      },
      {
        "start": 34.96,
        "duration": 3.439,
        "text": "easy enough we get all of the playlists"
      },
      {
        "start": 37.6,
        "duration": 2.4,
        "text": "by user"
      },
      {
        "start": 38.399,
        "duration": 3.201,
        "text": "and we're doing a slightly more"
      },
      {
        "start": 40.0,
        "duration": 4.399,
        "text": "sophisticated method here of turning"
      },
      {
        "start": 41.6,
        "duration": 5.68,
        "text": "that into a pair rdd by calling key buy"
      },
      {
        "start": 44.399,
        "duration": 3.68,
        "text": "and we're picking out the movie id as a"
      },
      {
        "start": 47.28,
        "duration": 3.2,
        "text": "uuid"
      },
      {
        "start": 48.079,
        "duration": 3.361,
        "text": "to to make that the key likewise with"
      },
      {
        "start": 50.48,
        "duration": 3.04,
        "text": "movies we get"
      },
      {
        "start": 51.44,
        "duration": 3.439,
        "text": "all of the movies just select the movie"
      },
      {
        "start": 53.52,
        "duration": 3.44,
        "text": "id and"
      },
      {
        "start": 54.879,
        "duration": 3.281,
        "text": "key buy with that movie id now that's a"
      },
      {
        "start": 56.96,
        "duration": 3.759,
        "text": "pair rdd where"
      },
      {
        "start": 58.16,
        "duration": 4.48,
        "text": "effectively there is no value but that's"
      },
      {
        "start": 60.719,
        "duration": 2.801,
        "text": "fine for us we just want the rdd to"
      },
      {
        "start": 62.64,
        "duration": 2.64,
        "text": "contain"
      },
      {
        "start": 63.52,
        "duration": 3.84,
        "text": "a complete collection of all of the"
      },
      {
        "start": 65.28,
        "duration": 5.12,
        "text": "valid movies now we want"
      },
      {
        "start": 67.36,
        "duration": 6.24,
        "text": "the result to contain playlists"
      },
      {
        "start": 70.4,
        "duration": 4.88,
        "text": "that don't have a valid join key so this"
      },
      {
        "start": 73.6,
        "duration": 4.08,
        "text": "is going to call for a left"
      },
      {
        "start": 75.28,
        "duration": 5.12,
        "text": "outer join we're going to left out or"
      },
      {
        "start": 77.68,
        "duration": 3.52,
        "text": "join movies onto playlists as you see in"
      },
      {
        "start": 80.4,
        "duration": 2.399,
        "text": "that third"
      },
      {
        "start": 81.2,
        "duration": 3.04,
        "text": "line of code there the third section of"
      },
      {
        "start": 82.799,
        "duration": 3.841,
        "text": "code to keep only"
      },
      {
        "start": 84.24,
        "duration": 3.919,
        "text": "those tuples those rows where the second"
      },
      {
        "start": 86.64,
        "duration": 3.519,
        "text": "component is not defined"
      },
      {
        "start": 88.159,
        "duration": 3.521,
        "text": "that is where there is no valid movie"
      },
      {
        "start": 90.159,
        "duration": 4.721,
        "text": "associated with"
      },
      {
        "start": 91.68,
        "duration": 5.52,
        "text": "that playlist entry then we'll map those"
      },
      {
        "start": 94.88,
        "duration": 3.599,
        "text": "since we have this nice polite pair rdd"
      },
      {
        "start": 97.2,
        "duration": 2.64,
        "text": "that contains a collection of the"
      },
      {
        "start": 98.479,
        "duration": 3.521,
        "text": "playlist"
      },
      {
        "start": 99.84,
        "duration": 3.52,
        "text": "row and the movie row we really only"
      },
      {
        "start": 102.0,
        "duration": 2.72,
        "text": "care about the playlist row so we're"
      },
      {
        "start": 103.36,
        "duration": 2.48,
        "text": "going to map that and pluck out the"
      },
      {
        "start": 104.72,
        "duration": 4.16,
        "text": "playlist row"
      },
      {
        "start": 105.84,
        "duration": 6.08,
        "text": "and make that our new result"
      },
      {
        "start": 108.88,
        "duration": 4.879,
        "text": "rdd which finally we'll collect and"
      },
      {
        "start": 111.92,
        "duration": 3.44,
        "text": "iterate over and print out and we'll"
      },
      {
        "start": 113.759,
        "duration": 3.601,
        "text": "show you just one row of that"
      },
      {
        "start": 115.36,
        "duration": 3.84,
        "text": "that you'll notice is a cassandra row at"
      },
      {
        "start": 117.36,
        "duration": 4.48,
        "text": "that point this is no longer a pair"
      },
      {
        "start": 119.2,
        "duration": 4.16,
        "text": "rdd after the map call in the left inner"
      },
      {
        "start": 121.84,
        "duration": 3.279,
        "text": "join sequence"
      },
      {
        "start": 123.36,
        "duration": 3.52,
        "text": "that stopped being a pair rdd and it's"
      },
      {
        "start": 125.119,
        "duration": 3.76,
        "text": "just now a collection of cassandra rows"
      },
      {
        "start": 126.88,
        "duration": 3.76,
        "text": "but we've got those rows and we can now"
      },
      {
        "start": 128.879,
        "duration": 2.881,
        "text": "say hey here's a playlist entry that"
      },
      {
        "start": 130.64,
        "duration": 1.679,
        "text": "points to something that doesn't really"
      },
      {
        "start": 131.76,
        "duration": 1.92,
        "text": "exist"
      },
      {
        "start": 132.319,
        "duration": 2.721,
        "text": "we can decide what we want to do with"
      },
      {
        "start": 133.68,
        "duration": 2.72,
        "text": "that do we want to delete it do we want"
      },
      {
        "start": 135.04,
        "duration": 1.76,
        "text": "to flag it do we want to put it in a"
      },
      {
        "start": 136.4,
        "duration": 2.8,
        "text": "queue"
      },
      {
        "start": 136.8,
        "duration": 3.84,
        "text": "and mention it to the user all decisions"
      },
      {
        "start": 139.2,
        "duration": 3.679,
        "text": "the application can make"
      },
      {
        "start": 140.64,
        "duration": 3.2,
        "text": "but we've done distributed referential"
      },
      {
        "start": 142.879,
        "duration": 2.72,
        "text": "integrity checking"
      },
      {
        "start": 143.84,
        "duration": 3.6,
        "text": "with this left outer join now we have"
      },
      {
        "start": 145.599,
        "duration": 5.28,
        "text": "the set oriented pair"
      },
      {
        "start": 147.44,
        "duration": 6.159,
        "text": "rdd transformations these are union"
      },
      {
        "start": 150.879,
        "duration": 4.561,
        "text": "intersection and difference you see"
      },
      {
        "start": 153.599,
        "duration": 3.761,
        "text": "those venn diagrams there if you're not"
      },
      {
        "start": 155.44,
        "duration": 3.76,
        "text": "familiar with those as set terms"
      },
      {
        "start": 157.36,
        "duration": 3.28,
        "text": "those very helpfully illustrate what"
      },
      {
        "start": 159.2,
        "duration": 3.28,
        "text": "these three things do"
      },
      {
        "start": 160.64,
        "duration": 4.16,
        "text": "they are quite easy to call we'll still"
      },
      {
        "start": 162.48,
        "duration": 4.479,
        "text": "show you some code and some examples"
      },
      {
        "start": 164.8,
        "duration": 3.6,
        "text": "of useful things we might do with these"
      },
      {
        "start": 166.959,
        "duration": 3.441,
        "text": "if you really want to watch these work"
      },
      {
        "start": 168.4,
        "duration": 3.76,
        "text": "you can type this code in all of the"
      },
      {
        "start": 170.4,
        "duration": 3.199,
        "text": "examples are based on parallelized"
      },
      {
        "start": 172.16,
        "duration": 3.2,
        "text": "collection literals"
      },
      {
        "start": 173.599,
        "duration": 3.601,
        "text": "so this is stuff you can play with in"
      },
      {
        "start": 175.36,
        "duration": 3.92,
        "text": "the spark shell really easily a key"
      },
      {
        "start": 177.2,
        "duration": 4.16,
        "text": "based union is going to take those two"
      },
      {
        "start": 179.28,
        "duration": 3.599,
        "text": "arrays and it's really easiest to"
      },
      {
        "start": 181.36,
        "duration": 2.64,
        "text": "visualize them in terms of the tables"
      },
      {
        "start": 182.879,
        "duration": 2.801,
        "text": "the rdds you see down"
      },
      {
        "start": 184.0,
        "duration": 3.44,
        "text": "below but it's going to combine them"
      },
      {
        "start": 185.68,
        "duration": 2.4,
        "text": "it's going to take anything that's in"
      },
      {
        "start": 187.44,
        "duration": 2.56,
        "text": "the first one"
      },
      {
        "start": 188.08,
        "duration": 3.84,
        "text": "anything that's in the second one and"
      },
      {
        "start": 190.0,
        "duration": 3.68,
        "text": "give us an output rdd that contains"
      },
      {
        "start": 191.92,
        "duration": 3.44,
        "text": "all of that and yes duplicates are"
      },
      {
        "start": 193.68,
        "duration": 3.04,
        "text": "allowed if you want a key-based"
      },
      {
        "start": 195.36,
        "duration": 2.56,
        "text": "intersection it turns out you have to do"
      },
      {
        "start": 196.72,
        "duration": 3.04,
        "text": "a little bit of this work on your own"
      },
      {
        "start": 197.92,
        "duration": 4.959,
        "text": "this is an important set operation"
      },
      {
        "start": 199.76,
        "duration": 4.72,
        "text": "that takes two rdds as input and gives"
      },
      {
        "start": 202.879,
        "duration": 2.72,
        "text": "you an output containing the keys that"
      },
      {
        "start": 204.48,
        "duration": 3.759,
        "text": "are common to both"
      },
      {
        "start": 205.599,
        "duration": 5.2,
        "text": "however unlike a join it doesn't do any"
      },
      {
        "start": 208.239,
        "duration": 4.56,
        "text": "sort of collection or aggregation of"
      },
      {
        "start": 210.799,
        "duration": 4.16,
        "text": "the values you're still going to get one"
      },
      {
        "start": 212.799,
        "duration": 4.72,
        "text": "record in the output rdd"
      },
      {
        "start": 214.959,
        "duration": 4.401,
        "text": "per record in the input rdd you don't"
      },
      {
        "start": 217.519,
        "duration": 4.161,
        "text": "get you don't get iterables"
      },
      {
        "start": 219.36,
        "duration": 3.599,
        "text": "of the values that you saw on the inputs"
      },
      {
        "start": 221.68,
        "duration": 2.639,
        "text": "so looking at the slide"
      },
      {
        "start": 222.959,
        "duration": 3.441,
        "text": "we see we have to do a little bit of"
      },
      {
        "start": 224.319,
        "duration": 5.28,
        "text": "work first we're going to take that"
      },
      {
        "start": 226.4,
        "duration": 6.24,
        "text": "rdd a group it by key and"
      },
      {
        "start": 229.599,
        "duration": 5.36,
        "text": "join it to be grouped by key that's"
      },
      {
        "start": 232.64,
        "duration": 5.76,
        "text": "really what a key based intersection is"
      },
      {
        "start": 234.959,
        "duration": 4.961,
        "text": "is a join however at the end we'll flat"
      },
      {
        "start": 238.4,
        "duration": 2.399,
        "text": "map the results we'll flat map the"
      },
      {
        "start": 239.92,
        "duration": 2.959,
        "text": "values"
      },
      {
        "start": 240.799,
        "duration": 3.36,
        "text": "and unroll the collections that the join"
      },
      {
        "start": 242.879,
        "duration": 3.121,
        "text": "created for us"
      },
      {
        "start": 244.159,
        "duration": 4.64,
        "text": "key based difference also fairly"
      },
      {
        "start": 246.0,
        "duration": 4.959,
        "text": "straightforward it takes a second rdd"
      },
      {
        "start": 248.799,
        "duration": 4.561,
        "text": "and finds all of the occurrences of"
      },
      {
        "start": 250.959,
        "duration": 4.961,
        "text": "those keys in the first rdd"
      },
      {
        "start": 253.36,
        "duration": 3.68,
        "text": "and strips them out so you get only keys"
      },
      {
        "start": 255.92,
        "duration": 3.12,
        "text": "in the first rdd"
      },
      {
        "start": 257.04,
        "duration": 4.08,
        "text": "that didn't happen in the second one and"
      },
      {
        "start": 259.04,
        "duration": 5.52,
        "text": "as you can see in the example here"
      },
      {
        "start": 261.12,
        "duration": 7.04,
        "text": "k1 k2 k1 and k3 occur"
      },
      {
        "start": 264.56,
        "duration": 7.199,
        "text": "in the first rdd the second has k1 k2"
      },
      {
        "start": 268.16,
        "duration": 5.759,
        "text": "and k4 k3 is the only one that escapes"
      },
      {
        "start": 271.759,
        "duration": 4.401,
        "text": "the notice of that second rdd"
      },
      {
        "start": 273.919,
        "duration": 4.321,
        "text": "and it's what occurs in the output we"
      },
      {
        "start": 276.16,
        "duration": 4.08,
        "text": "can actually use that to do a simplified"
      },
      {
        "start": 278.24,
        "duration": 4.32,
        "text": "bit of data validation a little while"
      },
      {
        "start": 280.24,
        "duration": 3.28,
        "text": "ago we found all the playlists that"
      },
      {
        "start": 282.56,
        "duration": 2.72,
        "text": "didn't have"
      },
      {
        "start": 283.52,
        "duration": 3.2,
        "text": "valid movies we used a left inner join"
      },
      {
        "start": 285.28,
        "duration": 2.56,
        "text": "for that we can actually do that with"
      },
      {
        "start": 286.72,
        "duration": 2.56,
        "text": "subtract by key"
      },
      {
        "start": 287.84,
        "duration": 3.44,
        "text": "let's take a look at the code first we"
      },
      {
        "start": 289.28,
        "duration": 4.0,
        "text": "get the playlists from the database we"
      },
      {
        "start": 291.28,
        "duration": 2.72,
        "text": "turn them into a pair rdd based on movie"
      },
      {
        "start": 293.28,
        "duration": 3.68,
        "text": "id"
      },
      {
        "start": 294.0,
        "duration": 5.199,
        "text": "then we get the movies and we turn them"
      },
      {
        "start": 296.96,
        "duration": 4.56,
        "text": "into a pair rdd based on movie id"
      },
      {
        "start": 299.199,
        "duration": 3.44,
        "text": "again kind of that silly pair rdd in the"
      },
      {
        "start": 301.52,
        "duration": 2.72,
        "text": "movie example"
      },
      {
        "start": 302.639,
        "duration": 3.601,
        "text": "uh because there is no value but that's"
      },
      {
        "start": 304.24,
        "duration": 3.6,
        "text": "okay that's all we need then we take the"
      },
      {
        "start": 306.24,
        "duration": 5.04,
        "text": "playlists and subtract"
      },
      {
        "start": 307.84,
        "duration": 5.6,
        "text": "the movies by value collect for each"
      },
      {
        "start": 311.28,
        "duration": 3.52,
        "text": "and you're done it's a much simpler way"
      },
      {
        "start": 313.44,
        "duration": 2.16,
        "text": "to think of it in terms of a set"
      },
      {
        "start": 314.8,
        "duration": 2.959,
        "text": "difference"
      },
      {
        "start": 315.6,
        "duration": 4.319,
        "text": "than the inner join logic that we wrote"
      },
      {
        "start": 317.759,
        "duration": 3.921,
        "text": "before so you can see that the mere fact"
      },
      {
        "start": 319.919,
        "duration": 4.241,
        "text": "of breaking up an rdd into"
      },
      {
        "start": 321.68,
        "duration": 3.76,
        "text": "a key value structure exposes all kinds"
      },
      {
        "start": 324.16,
        "duration": 3.44,
        "text": "of powerful functionality"
      },
      {
        "start": 325.44,
        "duration": 4.56,
        "text": "and a few really useful apis that"
      },
      {
        "start": 327.6,
        "duration": 3.92,
        "text": "address very practical use cases that we"
      },
      {
        "start": 330.0,
        "duration": 2.4,
        "text": "can apply even to our fictional video"
      },
      {
        "start": 331.52,
        "duration": 2.32,
        "text": "hosting website"
      },
      {
        "start": 332.4,
        "duration": 3.359,
        "text": "this stuff is super useful and i hope"
      },
      {
        "start": 333.84,
        "duration": 2.24,
        "text": "you've gotten a feel for how pair rdds"
      },
      {
        "start": 335.759,
        "duration": 4.081,
        "text": "can"
      },
      {
        "start": 336.08,
        "duration": 3.76,
        "text": "unlock a lot of the power of spark"
      },
      {
        "start": 341.04,
        "duration": 4.699,
        "text": "[Music]"
      }
    ],
    "error": null,
    "error_type": null
  },
  "collected_at": "2025-12-15T23:37:31.065204+00:00"
}