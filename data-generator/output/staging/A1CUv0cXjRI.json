{
  "video_id": "A1CUv0cXjRI",
  "title": "DS330.31 Recommender Traversals | DataStax Enterprise 6 Graph",
  "description": "#DataStaxAcademy #DS330\nDS330.31 Recommender Traversals\nRecommendation engines are a really good common use case for graph. In this unit, we see how we might build a recommendation engine for our KillrVideo project using Gremlin and DataStax Enterprise Graph.\n\nLEARN FOR FREE at https://academy.datastax.com -- access all the FREE complete courses, tutorials, and hands-on exercises.\n\nASK QUESTIONS at https://community.datastax.com -- where experts from DataStax & the Apache Cassandra community share their expertise everyday.",
  "published_at": "2020-08-16T01:35:55Z",
  "thumbnail": "https://i.ytimg.com/vi/A1CUv0cXjRI/maxresdefault.jpg",
  "channel_title": "DataStax Developers",
  "channel_id": "UCAIQY251avaMv7bBv5PCo-A",
  "tags": [
    "cassandra",
    "datastax",
    "tutorial",
    "apache_cassandra"
  ],
  "url": "https://www.youtube.com/watch?v=A1CUv0cXjRI",
  "transcript": {
    "available": true,
    "language": "English (auto-generated)",
    "language_code": "en",
    "is_generated": true,
    "text": "[Music] if you've done any research into the world of graph databases then you've probably noticed that recommendation engines are really good common use case for graph let's dive in to see how we might build a recommendation engine for our killer video project using gremlin and datastax enterprise graph let's talk a little bit about recommendation system basics now a recommendation system falls under the category of predictive analytics at a high level our goal is to predict how a user will respond to an option and then recommend only favorable options in our example that translates to recommending movies that a user is likely to enjoy we'll be looking at two components of this process with predictive modeling we will analyze the data in order to build a model that will enable us to predict how likely a user is to enjoy a particular movie at this point this could be an oltp or an olap implementation in the second component we'll look at recommendation service where we will present users with movie options that they're likely to enjoy this will be an oltp implementation here we discuss the steps we might take for a content based predictive modeling approach as you can see this approach is pretty straightforward we start by extracting movie features such as year genre and actors and then use those features to find similar movies this is all motivated by the hypothesis that users will enjoy movies similar to those that they have enjoyed in the past so we recommend movies that are similar to the movies a user has been known to like now let's discuss what our strategy might be for a collaborative filtering approach we start by extracting user features such as age gender and probably most importantly movie ratings once we know the similarities between users recommending a movie is pretty simple we look at similar users and what movies they've enjoyed and then we recommend those movies to our target user now let's take a look at a hybrid approach that incorporates concepts from both of the previous examples in this case we can use our knowledge of movie similarity and user similarity to recommend movies that meet the following two conditions first we want to recommend movies that are liked by users who are similar to the target user and second we recommend movies that are similar to the movies that our target user has already enjoyed let's think about some of the other considerations that go along with building a recommendation service depending on your use case and approach you will either compute recommendations using a predictive model or retrieve precomputed recommendations in either case you will then order your recommendations based on relevance and finally determine how many recommendations to present to the user here is our killer video graph schema we have four types of vertices movies users genres and people they can be related to each other by different types of relationships users may know each other and users can rate movies movies belong to genres can have actors directors composers screenwriters and cinematographers and of course we have various vertex properties and one edge property in this schema user defined vertex ids are underlined we have no meta properties in this schema but we do have one multi-value property and that is the production property please take a moment to study this schema as it'll help you as we work through our example so let's start to fill in some of the details of our specific approach we're going to use the hybrid approach to predictive modeling we will consider two movies similar if they share the same genre and two users similar if they've both highly rated the same movie this could be implemented as an olap or an oltp solution but if you go with oltp approach then you're going to want to make sure that you restrict the number of users and movies in your working set a quick word of wisdom you don't know how your service will perform until you've tested it at scale finally we will order movies based on their popularity among similar users and display a small number of those recommendations to our target user so how would we go about coding something like this well for starters let's find the top genre for our target user i'll walk you through this traversal line by line we start by finding the target user vertex then we look at what movies that user has rated and what genre each of those movies belongs to then we use the group count step basically as a score for each genre based on how many times it has appeared group count produces a map of key value pairs where the key is the name of a genre and the value is the number of times that genre appeared for the movies rated by our target user we use the order step to sort the map such that the genres with the highest score will be at the front then we simply select the keys which in our case are the genre names and unfold the list randomly sampling one element from the top five in this example our target genre happens to be kids we didn't discuss this previously but hopefully it's obvious that we don't want to recommend movies to our target user that they've already watched now the killer video project doesn't track watch history so we're cheating a little bit here by using the rated edge so with this traversal we're simply looking at all the movies our target user is rated and then filtering to include only the movies of our target genre in this example you can see that our target user has already watched the lion king and aladdin which are both movies in the kids genre as we briefly discussed previously the key to ensuring good performance at scale for an oltp traversal is managing your working set obviously if you have millions of users it won't be realistic to consider all of them in a real-time recommendation service so in this slide we're just setting up some of the parameters of our traversal now for the fun part this traversal is a little bit of a beast but don't worry i'm going to walk you through it in the first two lines we're grabbing movies that are rated highly by our target user and have our target genre in the next two lines we look at other users who enjoyed the movies from the previous section with some extra filtering to ensure that our target user doesn't sneak into that group and lastly we simply sample an arbitrary set of those users so now our working set is made up of users who enjoy the same movies as our target user for the specified target genre in the next three lines we gather the other movies that users liked that have our target genre we're also filtering out movies that our target user has already watched now our working set is made up of movies with the target genre that have also been liked by similar users then it's just a matter of crunching the scores we group the movies by their sax score order the underlying map by those scores and then grab the top bunch staring at a wall of gremlin like this can be daunting there's a lot of business logic packed into this snippet of code the key is to break it down into manageable sections like we did here and there is certainly still room for some improvement you could look at incorporating other user similarity factors and additional movie similarity factors you could also modify this traversal so it helps users branch out into other genres that they might be likely to enjoy you could consider a more sophisticated scoring system that considers movies a user disliked or possibly didn't finish watching with all these tools and concepts in mind i think you're ready to give it a shot for yourself so go check out the exercise",
    "segments": [
      {
        "start": 1.47,
        "duration": 5.31,
        "text": "[Music]"
      },
      {
        "start": 6.96,
        "duration": 3.2,
        "text": "if you've done any research into the"
      },
      {
        "start": 8.559,
        "duration": 2.96,
        "text": "world of graph databases"
      },
      {
        "start": 10.16,
        "duration": 3.519,
        "text": "then you've probably noticed that"
      },
      {
        "start": 11.519,
        "duration": 4.24,
        "text": "recommendation engines are really good"
      },
      {
        "start": 13.679,
        "duration": 3.281,
        "text": "common use case for graph let's dive in"
      },
      {
        "start": 15.759,
        "duration": 2.481,
        "text": "to see how we might build a"
      },
      {
        "start": 16.96,
        "duration": 2.96,
        "text": "recommendation engine"
      },
      {
        "start": 18.24,
        "duration": 4.32,
        "text": "for our killer video project using"
      },
      {
        "start": 19.92,
        "duration": 4.0,
        "text": "gremlin and datastax enterprise graph"
      },
      {
        "start": 22.56,
        "duration": 3.28,
        "text": "let's talk a little bit about"
      },
      {
        "start": 23.92,
        "duration": 3.84,
        "text": "recommendation system basics"
      },
      {
        "start": 25.84,
        "duration": 4.24,
        "text": "now a recommendation system falls under"
      },
      {
        "start": 27.76,
        "duration": 4.56,
        "text": "the category of predictive analytics"
      },
      {
        "start": 30.08,
        "duration": 4.24,
        "text": "at a high level our goal is to predict"
      },
      {
        "start": 32.32,
        "duration": 3.52,
        "text": "how a user will respond to an option"
      },
      {
        "start": 34.32,
        "duration": 3.28,
        "text": "and then recommend only favorable"
      },
      {
        "start": 35.84,
        "duration": 3.6,
        "text": "options in our example"
      },
      {
        "start": 37.6,
        "duration": 3.92,
        "text": "that translates to recommending movies"
      },
      {
        "start": 39.44,
        "duration": 3.6,
        "text": "that a user is likely to enjoy"
      },
      {
        "start": 41.52,
        "duration": 4.16,
        "text": "we'll be looking at two components of"
      },
      {
        "start": 43.04,
        "duration": 4.72,
        "text": "this process with predictive modeling"
      },
      {
        "start": 45.68,
        "duration": 3.92,
        "text": "we will analyze the data in order to"
      },
      {
        "start": 47.76,
        "duration": 4.0,
        "text": "build a model that will enable us to"
      },
      {
        "start": 49.6,
        "duration": 3.279,
        "text": "predict how likely a user is to enjoy a"
      },
      {
        "start": 51.76,
        "duration": 3.6,
        "text": "particular movie"
      },
      {
        "start": 52.879,
        "duration": 4.641,
        "text": "at this point this could be an oltp or"
      },
      {
        "start": 55.36,
        "duration": 4.24,
        "text": "an olap implementation"
      },
      {
        "start": 57.52,
        "duration": 3.6,
        "text": "in the second component we'll look at"
      },
      {
        "start": 59.6,
        "duration": 3.279,
        "text": "recommendation service"
      },
      {
        "start": 61.12,
        "duration": 3.92,
        "text": "where we will present users with movie"
      },
      {
        "start": 62.879,
        "duration": 5.201,
        "text": "options that they're likely to enjoy"
      },
      {
        "start": 65.04,
        "duration": 5.119,
        "text": "this will be an oltp implementation"
      },
      {
        "start": 68.08,
        "duration": 4.16,
        "text": "here we discuss the steps we might take"
      },
      {
        "start": 70.159,
        "duration": 3.521,
        "text": "for a content based predictive modeling"
      },
      {
        "start": 72.24,
        "duration": 3.28,
        "text": "approach"
      },
      {
        "start": 73.68,
        "duration": 4.16,
        "text": "as you can see this approach is pretty"
      },
      {
        "start": 75.52,
        "duration": 4.0,
        "text": "straightforward we start by extracting"
      },
      {
        "start": 77.84,
        "duration": 4.0,
        "text": "movie features such as year"
      },
      {
        "start": 79.52,
        "duration": 4.56,
        "text": "genre and actors and then use those"
      },
      {
        "start": 81.84,
        "duration": 4.4,
        "text": "features to find similar movies"
      },
      {
        "start": 84.08,
        "duration": 4.399,
        "text": "this is all motivated by the hypothesis"
      },
      {
        "start": 86.24,
        "duration": 4.0,
        "text": "that users will enjoy movies similar to"
      },
      {
        "start": 88.479,
        "duration": 3.68,
        "text": "those that they have enjoyed in the past"
      },
      {
        "start": 90.24,
        "duration": 3.68,
        "text": "so we recommend movies that are similar"
      },
      {
        "start": 92.159,
        "duration": 3.28,
        "text": "to the movies a user has been known to"
      },
      {
        "start": 93.92,
        "duration": 3.12,
        "text": "like"
      },
      {
        "start": 95.439,
        "duration": 3.36,
        "text": "now let's discuss what our strategy"
      },
      {
        "start": 97.04,
        "duration": 2.48,
        "text": "might be for a collaborative filtering"
      },
      {
        "start": 98.799,
        "duration": 2.96,
        "text": "approach"
      },
      {
        "start": 99.52,
        "duration": 3.2,
        "text": "we start by extracting user features"
      },
      {
        "start": 101.759,
        "duration": 3.121,
        "text": "such as age"
      },
      {
        "start": 102.72,
        "duration": 3.84,
        "text": "gender and probably most importantly"
      },
      {
        "start": 104.88,
        "duration": 3.36,
        "text": "movie ratings"
      },
      {
        "start": 106.56,
        "duration": 3.76,
        "text": "once we know the similarities between"
      },
      {
        "start": 108.24,
        "duration": 3.12,
        "text": "users recommending a movie is pretty"
      },
      {
        "start": 110.32,
        "duration": 3.119,
        "text": "simple"
      },
      {
        "start": 111.36,
        "duration": 3.039,
        "text": "we look at similar users and what movies"
      },
      {
        "start": 113.439,
        "duration": 2.561,
        "text": "they've enjoyed"
      },
      {
        "start": 114.399,
        "duration": 4.4,
        "text": "and then we recommend those movies to"
      },
      {
        "start": 116.0,
        "duration": 2.799,
        "text": "our target user"
      },
      {
        "start": 119.28,
        "duration": 3.68,
        "text": "now let's take a look at a hybrid"
      },
      {
        "start": 120.799,
        "duration": 4.32,
        "text": "approach that incorporates concepts from"
      },
      {
        "start": 122.96,
        "duration": 3.839,
        "text": "both of the previous examples"
      },
      {
        "start": 125.119,
        "duration": 4.321,
        "text": "in this case we can use our knowledge of"
      },
      {
        "start": 126.799,
        "duration": 4.16,
        "text": "movie similarity and user similarity"
      },
      {
        "start": 129.44,
        "duration": 3.12,
        "text": "to recommend movies that meet the"
      },
      {
        "start": 130.959,
        "duration": 3.521,
        "text": "following two conditions"
      },
      {
        "start": 132.56,
        "duration": 3.84,
        "text": "first we want to recommend movies that"
      },
      {
        "start": 134.48,
        "duration": 3.52,
        "text": "are liked by users who are similar to"
      },
      {
        "start": 136.4,
        "duration": 3.919,
        "text": "the target user"
      },
      {
        "start": 138.0,
        "duration": 4.0,
        "text": "and second we recommend movies that are"
      },
      {
        "start": 140.319,
        "duration": 4.801,
        "text": "similar to the movies that our target"
      },
      {
        "start": 142.0,
        "duration": 4.8,
        "text": "user has already enjoyed let's think"
      },
      {
        "start": 145.12,
        "duration": 2.8,
        "text": "about some of the other considerations"
      },
      {
        "start": 146.8,
        "duration": 2.64,
        "text": "that go along with building a"
      },
      {
        "start": 147.92,
        "duration": 3.599,
        "text": "recommendation service"
      },
      {
        "start": 149.44,
        "duration": 3.84,
        "text": "depending on your use case and approach"
      },
      {
        "start": 151.519,
        "duration": 3.201,
        "text": "you will either compute recommendations"
      },
      {
        "start": 153.28,
        "duration": 4.239,
        "text": "using a predictive model"
      },
      {
        "start": 154.72,
        "duration": 3.84,
        "text": "or retrieve precomputed recommendations"
      },
      {
        "start": 157.519,
        "duration": 2.961,
        "text": "in either case"
      },
      {
        "start": 158.56,
        "duration": 3.12,
        "text": "you will then order your recommendations"
      },
      {
        "start": 160.48,
        "duration": 2.64,
        "text": "based on relevance"
      },
      {
        "start": 161.68,
        "duration": 5.12,
        "text": "and finally determine how many"
      },
      {
        "start": 163.12,
        "duration": 3.68,
        "text": "recommendations to present to the user"
      },
      {
        "start": 168.48,
        "duration": 4.08,
        "text": "here is our killer video graph schema we"
      },
      {
        "start": 170.8,
        "duration": 4.799,
        "text": "have four types of vertices"
      },
      {
        "start": 172.56,
        "duration": 4.64,
        "text": "movies users genres and people"
      },
      {
        "start": 175.599,
        "duration": 3.441,
        "text": "they can be related to each other by"
      },
      {
        "start": 177.2,
        "duration": 4.0,
        "text": "different types of relationships"
      },
      {
        "start": 179.04,
        "duration": 3.36,
        "text": "users may know each other and users can"
      },
      {
        "start": 181.2,
        "duration": 4.08,
        "text": "rate movies"
      },
      {
        "start": 182.4,
        "duration": 3.6,
        "text": "movies belong to genres can have actors"
      },
      {
        "start": 185.28,
        "duration": 2.239,
        "text": "directors"
      },
      {
        "start": 186.0,
        "duration": 3.84,
        "text": "composers screenwriters and"
      },
      {
        "start": 187.519,
        "duration": 4.08,
        "text": "cinematographers and of course"
      },
      {
        "start": 189.84,
        "duration": 3.84,
        "text": "we have various vertex properties and"
      },
      {
        "start": 191.599,
        "duration": 4.64,
        "text": "one edge property in this schema"
      },
      {
        "start": 193.68,
        "duration": 4.08,
        "text": "user defined vertex ids are underlined"
      },
      {
        "start": 196.239,
        "duration": 3.28,
        "text": "we have no meta properties in this"
      },
      {
        "start": 197.76,
        "duration": 2.32,
        "text": "schema but we do have one multi-value"
      },
      {
        "start": 199.519,
        "duration": 2.64,
        "text": "property"
      },
      {
        "start": 200.08,
        "duration": 3.439,
        "text": "and that is the production property"
      },
      {
        "start": 202.159,
        "duration": 2.8,
        "text": "please take a moment to study this"
      },
      {
        "start": 203.519,
        "duration": 4.241,
        "text": "schema as it'll help you as we work"
      },
      {
        "start": 204.959,
        "duration": 2.801,
        "text": "through our example"
      },
      {
        "start": 210.959,
        "duration": 4.081,
        "text": "so let's start to fill in some of the"
      },
      {
        "start": 212.319,
        "duration": 4.161,
        "text": "details of our specific approach"
      },
      {
        "start": 215.04,
        "duration": 3.6,
        "text": "we're going to use the hybrid approach"
      },
      {
        "start": 216.48,
        "duration": 3.679,
        "text": "to predictive modeling we will consider"
      },
      {
        "start": 218.64,
        "duration": 2.8,
        "text": "two movies similar if they share the"
      },
      {
        "start": 220.159,
        "duration": 3.121,
        "text": "same genre"
      },
      {
        "start": 221.44,
        "duration": 3.92,
        "text": "and two users similar if they've both"
      },
      {
        "start": 223.28,
        "duration": 4.239,
        "text": "highly rated the same movie"
      },
      {
        "start": 225.36,
        "duration": 3.76,
        "text": "this could be implemented as an olap or"
      },
      {
        "start": 227.519,
        "duration": 3.921,
        "text": "an oltp solution"
      },
      {
        "start": 229.12,
        "duration": 3.36,
        "text": "but if you go with oltp approach then"
      },
      {
        "start": 231.44,
        "duration": 2.64,
        "text": "you're going to want to make sure that"
      },
      {
        "start": 232.48,
        "duration": 3.36,
        "text": "you restrict the number of users and"
      },
      {
        "start": 234.08,
        "duration": 4.159,
        "text": "movies in your working set"
      },
      {
        "start": 235.84,
        "duration": 4.08,
        "text": "a quick word of wisdom you don't know"
      },
      {
        "start": 238.239,
        "duration": 3.521,
        "text": "how your service will perform until"
      },
      {
        "start": 239.92,
        "duration": 4.0,
        "text": "you've tested it at scale"
      },
      {
        "start": 241.76,
        "duration": 4.32,
        "text": "finally we will order movies based on"
      },
      {
        "start": 243.92,
        "duration": 3.679,
        "text": "their popularity among similar users"
      },
      {
        "start": 246.08,
        "duration": 5.12,
        "text": "and display a small number of those"
      },
      {
        "start": 247.599,
        "duration": 5.041,
        "text": "recommendations to our target user"
      },
      {
        "start": 251.2,
        "duration": 3.119,
        "text": "so how would we go about coding"
      },
      {
        "start": 252.64,
        "duration": 3.839,
        "text": "something like this"
      },
      {
        "start": 254.319,
        "duration": 4.48,
        "text": "well for starters let's find the top"
      },
      {
        "start": 256.479,
        "duration": 3.6,
        "text": "genre for our target user"
      },
      {
        "start": 258.799,
        "duration": 3.761,
        "text": "i'll walk you through this traversal"
      },
      {
        "start": 260.079,
        "duration": 4.321,
        "text": "line by line we start by finding the"
      },
      {
        "start": 262.56,
        "duration": 3.6,
        "text": "target user vertex"
      },
      {
        "start": 264.4,
        "duration": 4.0,
        "text": "then we look at what movies that user"
      },
      {
        "start": 266.16,
        "duration": 3.92,
        "text": "has rated and what genre each of those"
      },
      {
        "start": 268.4,
        "duration": 3.519,
        "text": "movies belongs to"
      },
      {
        "start": 270.08,
        "duration": 3.92,
        "text": "then we use the group count step"
      },
      {
        "start": 271.919,
        "duration": 4.481,
        "text": "basically as a score for each genre"
      },
      {
        "start": 274.0,
        "duration": 4.4,
        "text": "based on how many times it has appeared"
      },
      {
        "start": 276.4,
        "duration": 3.44,
        "text": "group count produces a map of key value"
      },
      {
        "start": 278.4,
        "duration": 3.76,
        "text": "pairs where the key"
      },
      {
        "start": 279.84,
        "duration": 4.48,
        "text": "is the name of a genre and the value is"
      },
      {
        "start": 282.16,
        "duration": 4.96,
        "text": "the number of times that genre appeared"
      },
      {
        "start": 284.32,
        "duration": 3.439,
        "text": "for the movies rated by our target user"
      },
      {
        "start": 287.12,
        "duration": 3.28,
        "text": "we use the"
      },
      {
        "start": 287.759,
        "duration": 4.481,
        "text": "order step to sort the map such that the"
      },
      {
        "start": 290.4,
        "duration": 2.88,
        "text": "genres with the highest score will be at"
      },
      {
        "start": 292.24,
        "duration": 3.2,
        "text": "the front"
      },
      {
        "start": 293.28,
        "duration": 3.84,
        "text": "then we simply select the keys which in"
      },
      {
        "start": 295.44,
        "duration": 4.08,
        "text": "our case are the genre names"
      },
      {
        "start": 297.12,
        "duration": 4.88,
        "text": "and unfold the list randomly sampling"
      },
      {
        "start": 299.52,
        "duration": 4.959,
        "text": "one element from the top five"
      },
      {
        "start": 302.0,
        "duration": 3.12,
        "text": "in this example our target genre happens"
      },
      {
        "start": 304.479,
        "duration": 3.921,
        "text": "to be"
      },
      {
        "start": 305.12,
        "duration": 4.88,
        "text": "kids we didn't discuss this previously"
      },
      {
        "start": 308.4,
        "duration": 3.28,
        "text": "but hopefully it's obvious that we don't"
      },
      {
        "start": 310.0,
        "duration": 3.759,
        "text": "want to recommend movies to our target"
      },
      {
        "start": 311.68,
        "duration": 3.92,
        "text": "user that they've already watched"
      },
      {
        "start": 313.759,
        "duration": 3.201,
        "text": "now the killer video project doesn't"
      },
      {
        "start": 315.6,
        "duration": 3.12,
        "text": "track watch history"
      },
      {
        "start": 316.96,
        "duration": 3.92,
        "text": "so we're cheating a little bit here by"
      },
      {
        "start": 318.72,
        "duration": 4.16,
        "text": "using the rated edge"
      },
      {
        "start": 320.88,
        "duration": 3.12,
        "text": "so with this traversal we're simply"
      },
      {
        "start": 322.88,
        "duration": 3.039,
        "text": "looking at all the movies"
      },
      {
        "start": 324.0,
        "duration": 3.919,
        "text": "our target user is rated and then"
      },
      {
        "start": 325.919,
        "duration": 3.84,
        "text": "filtering to include only the movies of"
      },
      {
        "start": 327.919,
        "duration": 3.28,
        "text": "our target genre"
      },
      {
        "start": 329.759,
        "duration": 3.521,
        "text": "in this example you can see that our"
      },
      {
        "start": 331.199,
        "duration": 3.44,
        "text": "target user has already watched the lion"
      },
      {
        "start": 333.28,
        "duration": 4.96,
        "text": "king and aladdin"
      },
      {
        "start": 334.639,
        "duration": 5.521,
        "text": "which are both movies in the kids genre"
      },
      {
        "start": 338.24,
        "duration": 3.36,
        "text": "as we briefly discussed previously the"
      },
      {
        "start": 340.16,
        "duration": 3.28,
        "text": "key to ensuring good performance at"
      },
      {
        "start": 341.6,
        "duration": 4.64,
        "text": "scale for an oltp traversal"
      },
      {
        "start": 343.44,
        "duration": 4.479,
        "text": "is managing your working set obviously"
      },
      {
        "start": 346.24,
        "duration": 3.44,
        "text": "if you have millions of users it won't"
      },
      {
        "start": 347.919,
        "duration": 3.601,
        "text": "be realistic to consider all of them in"
      },
      {
        "start": 349.68,
        "duration": 3.519,
        "text": "a real-time recommendation service"
      },
      {
        "start": 351.52,
        "duration": 4.48,
        "text": "so in this slide we're just setting up"
      },
      {
        "start": 353.199,
        "duration": 5.201,
        "text": "some of the parameters of our traversal"
      },
      {
        "start": 356.0,
        "duration": 4.0,
        "text": "now for the fun part this traversal is a"
      },
      {
        "start": 358.4,
        "duration": 4.239,
        "text": "little bit of a beast but don't worry"
      },
      {
        "start": 360.0,
        "duration": 4.56,
        "text": "i'm going to walk you through it"
      },
      {
        "start": 362.639,
        "duration": 3.601,
        "text": "in the first two lines we're grabbing"
      },
      {
        "start": 364.56,
        "duration": 2.56,
        "text": "movies that are rated highly by our"
      },
      {
        "start": 366.24,
        "duration": 3.28,
        "text": "target user"
      },
      {
        "start": 367.12,
        "duration": 3.12,
        "text": "and have our target genre in the next"
      },
      {
        "start": 369.52,
        "duration": 2.72,
        "text": "two lines"
      },
      {
        "start": 370.24,
        "duration": 3.519,
        "text": "we look at other users who enjoyed the"
      },
      {
        "start": 372.24,
        "duration": 3.36,
        "text": "movies from the previous section"
      },
      {
        "start": 373.759,
        "duration": 3.041,
        "text": "with some extra filtering to ensure that"
      },
      {
        "start": 375.6,
        "duration": 3.52,
        "text": "our target user"
      },
      {
        "start": 376.8,
        "duration": 4.48,
        "text": "doesn't sneak into that group and lastly"
      },
      {
        "start": 379.12,
        "duration": 3.76,
        "text": "we simply sample an arbitrary set of"
      },
      {
        "start": 381.28,
        "duration": 3.919,
        "text": "those users"
      },
      {
        "start": 382.88,
        "duration": 4.56,
        "text": "so now our working set is made up of"
      },
      {
        "start": 385.199,
        "duration": 4.161,
        "text": "users who enjoy the same movies as our"
      },
      {
        "start": 387.44,
        "duration": 2.96,
        "text": "target user for the specified target"
      },
      {
        "start": 389.36,
        "duration": 3.04,
        "text": "genre"
      },
      {
        "start": 390.4,
        "duration": 3.6,
        "text": "in the next three lines we gather the"
      },
      {
        "start": 392.4,
        "duration": 3.919,
        "text": "other movies that users"
      },
      {
        "start": 394.0,
        "duration": 4.0,
        "text": "liked that have our target genre we're"
      },
      {
        "start": 396.319,
        "duration": 3.921,
        "text": "also filtering out movies that our"
      },
      {
        "start": 398.0,
        "duration": 4.479,
        "text": "target user has already watched"
      },
      {
        "start": 400.24,
        "duration": 3.519,
        "text": "now our working set is made up of movies"
      },
      {
        "start": 402.479,
        "duration": 2.881,
        "text": "with the target genre"
      },
      {
        "start": 403.759,
        "duration": 3.44,
        "text": "that have also been liked by similar"
      },
      {
        "start": 405.36,
        "duration": 3.279,
        "text": "users then it's just a matter of"
      },
      {
        "start": 407.199,
        "duration": 3.601,
        "text": "crunching the scores"
      },
      {
        "start": 408.639,
        "duration": 4.4,
        "text": "we group the movies by their sax score"
      },
      {
        "start": 410.8,
        "duration": 5.36,
        "text": "order the underlying map by those scores"
      },
      {
        "start": 413.039,
        "duration": 4.641,
        "text": "and then grab the top bunch staring at a"
      },
      {
        "start": 416.16,
        "duration": 3.759,
        "text": "wall of gremlin like this can be"
      },
      {
        "start": 417.68,
        "duration": 3.76,
        "text": "daunting there's a lot of business logic"
      },
      {
        "start": 419.919,
        "duration": 3.441,
        "text": "packed into this snippet of code"
      },
      {
        "start": 421.44,
        "duration": 4.0,
        "text": "the key is to break it down into"
      },
      {
        "start": 423.36,
        "duration": 3.6,
        "text": "manageable sections like we did here"
      },
      {
        "start": 425.44,
        "duration": 3.039,
        "text": "and there is certainly still room for"
      },
      {
        "start": 426.96,
        "duration": 3.359,
        "text": "some improvement you could look at"
      },
      {
        "start": 428.479,
        "duration": 2.481,
        "text": "incorporating other user similarity"
      },
      {
        "start": 430.319,
        "duration": 2.961,
        "text": "factors"
      },
      {
        "start": 430.96,
        "duration": 4.639,
        "text": "and additional movie similarity factors"
      },
      {
        "start": 433.28,
        "duration": 4.56,
        "text": "you could also modify this traversal"
      },
      {
        "start": 435.599,
        "duration": 3.841,
        "text": "so it helps users branch out into other"
      },
      {
        "start": 437.84,
        "duration": 3.04,
        "text": "genres that they might be likely to"
      },
      {
        "start": 439.44,
        "duration": 3.28,
        "text": "enjoy"
      },
      {
        "start": 440.88,
        "duration": 4.08,
        "text": "you could consider a more sophisticated"
      },
      {
        "start": 442.72,
        "duration": 4.319,
        "text": "scoring system that considers movies a"
      },
      {
        "start": 444.96,
        "duration": 4.0,
        "text": "user disliked or possibly didn't finish"
      },
      {
        "start": 447.039,
        "duration": 3.44,
        "text": "watching"
      },
      {
        "start": 448.96,
        "duration": 2.959,
        "text": "with all these tools and concepts in"
      },
      {
        "start": 450.479,
        "duration": 5.041,
        "text": "mind i think you're ready to give it a"
      },
      {
        "start": 451.919,
        "duration": 3.601,
        "text": "shot for yourself so go check out the"
      },
      {
        "start": 456.12,
        "duration": 3.0,
        "text": "exercise"
      }
    ],
    "error": null,
    "error_type": null
  },
  "collected_at": "2025-12-15T22:26:25.132435+00:00"
}