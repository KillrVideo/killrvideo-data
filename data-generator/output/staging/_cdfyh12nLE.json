{
  "video_id": "_cdfyh12nLE",
  "title": "DS330.06 Understanding Graph Partitioning and Data Locality | DataStax Enterprise 6 Graph",
  "description": "#DataStaxAcademy #DS330\nDS330.06 Understanding Graph Partitioning and Data Locality\nIn this unit, we will introduce the concepts of graph partitoning and data locality. Graph partitoning involves the grouping of vertices and edges into sections called subgraphs. Data locality can be controlled through selective data partitioning.\n\nLEARN FOR FREE at https://academy.datastax.com -- access all the FREE complete courses, tutorials, and hands-on exercises.\n\nASK QUESTIONS at https://community.datastax.com -- where experts from DataStax & the Apache Cassandra community share their expertise everyday.",
  "published_at": "2020-08-16T01:20:30Z",
  "thumbnail": "https://i.ytimg.com/vi/_cdfyh12nLE/maxresdefault.jpg",
  "channel_title": "DataStax Developers",
  "channel_id": "UCAIQY251avaMv7bBv5PCo-A",
  "tags": [
    "cassandra",
    "datastax",
    "tutorial",
    "apache_cassandra"
  ],
  "url": "https://www.youtube.com/watch?v=_cdfyh12nLE",
  "transcript": {
    "available": true,
    "language": "English (auto-generated)",
    "language_code": "en",
    "is_generated": true,
    "text": "[Music] now let's discuss partitioning and data locality in dse graph in case you'd like more information on the subject you can always read my blog post from the data stacks academy website titled understanding graph locality let's first introduce the concept of graph partitioning for those who are familiar with dse you'll understand partitioning in the terms of apache cassandra that is apache cassandra stores data and partitions we have partition keys one of the main tricks to achieving those low millisecond p99s at scale with apache cassandra is to set up your data model properly around a good partitioned axis pattern for graphs partitioning means something slightly different with graphs partitioning refers to how one groups vertices and edges of a whole graph into specific sections called subgraphs this is done for performance analytics reasons security or data management purposes here you'll see an example of a graph being partitioned into three different subgraphs the trick of graph partitioning is to balance graph access patterns write patterns and data size constraints like most things in distributed architecture we're talking about trade-offs theoretically graph partitioning is an incredibly hard problem this is because of the complexities involved from highly connected components there is no magic algorithm that can generate optimal graph partitions for you for the best results you have to consider each individual use case and be creative in dse graph we can actually combine the concepts of partitions in both apache cassandra and graph theory to come up with practical implementation choices to solve real-world at scale graph challenges this is because of the way dse graph projects the graph model onto cassandra in this diagram we're looking at an oversimplified example to illustrate the concept of how graph partitioning is applied to cassandra and dse graph you can see in this diagram each colored subgraph maps to each partitioning schema within cassandra in this example we see three different sub graphs represented by three different colors and we see how those sub graphs map onto cassandra by the groupings of partitions using the same colors on the right you can control partitioning in dsc graph by carefully choosing vertex labels and vertex id design this is very similar to those working with the cassandra components of dse choosing vertex labels especially in the presence of entity type hierarchies can affect graph partitioning in dsc graph underneath the cover dse graph creates two cassandra tables for each vertex label or type that is created these cassandra tables use a primary key that corresponds to the vertex identifier this means that vertex property and edge data is always stored together on a node and we can use cassandra's wide row partition and clustering keys to further control data placement in dse graph data placement is the central implementation concept of graph partitioning in dse graph this technique is named user-defined vertex ids it's worth mentioning in older versions of dse graph dsc graph used to generate ids for users this it turns out resulted in sub-optimal data placement and impacts a graph's ability to scale using user-defined vertex ids is a recommended approach for working with graphs in dsc graph we have three types of user-defined vertex ids the first is a vertex id based on a simple partitioning key structure this is the most basic implementation in which every new vertex is created using unique cassandra partitions cassandra will hash the partition key and store the data randomly throughout the cluster this is the easiest method of implementation that ensures an even distribution of your data across your cluster but this also doesn't provide users with any control over data placement or locality in other words this is the most simplistic approach to graph partitioning you could even say this is a graph without partitioning the next user defined vertex type is to use composite partition keys this means that instead of just using one property to identify a unique vertex two or more properties are used to identify a unique vertex the results of this approach are very similar to the simple partition key approach we described on the previous slide the only difference is here we can use more than one property key to identify our partitioning the final user-defined vertex id type is a vertex id using partition and clustering keys this method provides the most control over graph partitioning and enables graph users to achieve data locality by using the same partition key property to identify multiple vertices that belong to the same sub-graph this is the most powerful design pattern as it allows multiple vertices to reside in the same physical partition and share the same node here you can see that we have two vertices with a partition key of alice in wonderland it would be very efficient to retrieve all movies with a given title by simply traversing on the partition key only dse graph will translate these operations to cassandra partition axis patterns which are very efficient okay so you now see how we can use the power of cassandra's wide row data model to achieve a practical solution to graph partitioning give this exercise a go and we'll be right here when you're ready to learn more about dse graph",
    "segments": [
      {
        "start": 1.47,
        "duration": 5.31,
        "text": "[Music]"
      },
      {
        "start": 7.279,
        "duration": 3.36,
        "text": "now let's discuss partitioning and data"
      },
      {
        "start": 8.88,
        "duration": 3.2,
        "text": "locality in dse graph"
      },
      {
        "start": 10.639,
        "duration": 3.281,
        "text": "in case you'd like more information on"
      },
      {
        "start": 12.08,
        "duration": 3.12,
        "text": "the subject you can always read my blog"
      },
      {
        "start": 13.92,
        "duration": 2.56,
        "text": "post from the data stacks academy"
      },
      {
        "start": 15.2,
        "duration": 3.839,
        "text": "website titled"
      },
      {
        "start": 16.48,
        "duration": 4.0,
        "text": "understanding graph locality let's first"
      },
      {
        "start": 19.039,
        "duration": 2.641,
        "text": "introduce the concept of graph"
      },
      {
        "start": 20.48,
        "duration": 2.959,
        "text": "partitioning"
      },
      {
        "start": 21.68,
        "duration": 3.439,
        "text": "for those who are familiar with dse"
      },
      {
        "start": 23.439,
        "duration": 4.16,
        "text": "you'll understand partitioning in the"
      },
      {
        "start": 25.119,
        "duration": 4.641,
        "text": "terms of apache cassandra"
      },
      {
        "start": 27.599,
        "duration": 3.6,
        "text": "that is apache cassandra stores data and"
      },
      {
        "start": 29.76,
        "duration": 3.84,
        "text": "partitions"
      },
      {
        "start": 31.199,
        "duration": 3.681,
        "text": "we have partition keys one of the main"
      },
      {
        "start": 33.6,
        "duration": 2.16,
        "text": "tricks to achieving those low"
      },
      {
        "start": 34.88,
        "duration": 3.999,
        "text": "millisecond"
      },
      {
        "start": 35.76,
        "duration": 5.2,
        "text": "p99s at scale with apache cassandra"
      },
      {
        "start": 38.879,
        "duration": 4.401,
        "text": "is to set up your data model properly"
      },
      {
        "start": 40.96,
        "duration": 4.72,
        "text": "around a good partitioned axis pattern"
      },
      {
        "start": 43.28,
        "duration": 3.36,
        "text": "for graphs partitioning means something"
      },
      {
        "start": 45.68,
        "duration": 2.96,
        "text": "slightly different"
      },
      {
        "start": 46.64,
        "duration": 4.079,
        "text": "with graphs partitioning refers to how"
      },
      {
        "start": 48.64,
        "duration": 5.2,
        "text": "one groups vertices and edges"
      },
      {
        "start": 50.719,
        "duration": 5.761,
        "text": "of a whole graph into specific sections"
      },
      {
        "start": 53.84,
        "duration": 3.92,
        "text": "called subgraphs this is done for"
      },
      {
        "start": 56.48,
        "duration": 4.559,
        "text": "performance"
      },
      {
        "start": 57.76,
        "duration": 5.2,
        "text": "analytics reasons security or data"
      },
      {
        "start": 61.039,
        "duration": 4.48,
        "text": "management purposes"
      },
      {
        "start": 62.96,
        "duration": 3.04,
        "text": "here you'll see an example of a graph"
      },
      {
        "start": 65.519,
        "duration": 2.081,
        "text": "being"
      },
      {
        "start": 66.0,
        "duration": 3.119,
        "text": "partitioned into three different"
      },
      {
        "start": 67.6,
        "duration": 3.44,
        "text": "subgraphs"
      },
      {
        "start": 69.119,
        "duration": 4.0,
        "text": "the trick of graph partitioning is to"
      },
      {
        "start": 71.04,
        "duration": 4.96,
        "text": "balance graph access patterns"
      },
      {
        "start": 73.119,
        "duration": 4.241,
        "text": "write patterns and data size constraints"
      },
      {
        "start": 76.0,
        "duration": 2.799,
        "text": "like most things in distributed"
      },
      {
        "start": 77.36,
        "duration": 3.439,
        "text": "architecture we're talking about"
      },
      {
        "start": 78.799,
        "duration": 3.601,
        "text": "trade-offs"
      },
      {
        "start": 80.799,
        "duration": 3.68,
        "text": "theoretically graph partitioning is an"
      },
      {
        "start": 82.4,
        "duration": 3.84,
        "text": "incredibly hard problem this is because"
      },
      {
        "start": 84.479,
        "duration": 3.441,
        "text": "of the complexities involved from highly"
      },
      {
        "start": 86.24,
        "duration": 3.36,
        "text": "connected components"
      },
      {
        "start": 87.92,
        "duration": 3.76,
        "text": "there is no magic algorithm that can"
      },
      {
        "start": 89.6,
        "duration": 2.479,
        "text": "generate optimal graph partitions for"
      },
      {
        "start": 91.68,
        "duration": 1.52,
        "text": "you"
      },
      {
        "start": 92.079,
        "duration": 3.201,
        "text": "for the best results you have to"
      },
      {
        "start": 93.2,
        "duration": 5.84,
        "text": "consider each individual use case"
      },
      {
        "start": 95.28,
        "duration": 4.799,
        "text": "and be creative in dse graph we can"
      },
      {
        "start": 99.04,
        "duration": 3.759,
        "text": "actually combine the"
      },
      {
        "start": 100.079,
        "duration": 4.961,
        "text": "concepts of partitions in both apache"
      },
      {
        "start": 102.799,
        "duration": 2.561,
        "text": "cassandra and graph theory to come up"
      },
      {
        "start": 105.04,
        "duration": 2.32,
        "text": "with"
      },
      {
        "start": 105.36,
        "duration": 3.2,
        "text": "practical implementation choices to"
      },
      {
        "start": 107.36,
        "duration": 3.52,
        "text": "solve real-world"
      },
      {
        "start": 108.56,
        "duration": 4.239,
        "text": "at scale graph challenges this is"
      },
      {
        "start": 110.88,
        "duration": 3.919,
        "text": "because of the way dse graph projects"
      },
      {
        "start": 112.799,
        "duration": 3.841,
        "text": "the graph model onto cassandra"
      },
      {
        "start": 114.799,
        "duration": 4.32,
        "text": "in this diagram we're looking at an"
      },
      {
        "start": 116.64,
        "duration": 4.56,
        "text": "oversimplified example to illustrate the"
      },
      {
        "start": 119.119,
        "duration": 5.201,
        "text": "concept of how graph partitioning is"
      },
      {
        "start": 121.2,
        "duration": 5.68,
        "text": "applied to cassandra and dse graph"
      },
      {
        "start": 124.32,
        "duration": 3.52,
        "text": "you can see in this diagram each colored"
      },
      {
        "start": 126.88,
        "duration": 3.84,
        "text": "subgraph"
      },
      {
        "start": 127.84,
        "duration": 4.16,
        "text": "maps to each partitioning schema within"
      },
      {
        "start": 130.72,
        "duration": 3.519,
        "text": "cassandra"
      },
      {
        "start": 132.0,
        "duration": 3.68,
        "text": "in this example we see three different"
      },
      {
        "start": 134.239,
        "duration": 2.64,
        "text": "sub graphs represented by three"
      },
      {
        "start": 135.68,
        "duration": 3.919,
        "text": "different colors"
      },
      {
        "start": 136.879,
        "duration": 3.601,
        "text": "and we see how those sub graphs map onto"
      },
      {
        "start": 139.599,
        "duration": 3.201,
        "text": "cassandra"
      },
      {
        "start": 140.48,
        "duration": 3.2,
        "text": "by the groupings of partitions using the"
      },
      {
        "start": 142.8,
        "duration": 3.439,
        "text": "same colors"
      },
      {
        "start": 143.68,
        "duration": 4.48,
        "text": "on the right you can control"
      },
      {
        "start": 146.239,
        "duration": 4.0,
        "text": "partitioning in dsc graph by carefully"
      },
      {
        "start": 148.16,
        "duration": 3.04,
        "text": "choosing vertex labels and vertex id"
      },
      {
        "start": 150.239,
        "duration": 2.801,
        "text": "design"
      },
      {
        "start": 151.2,
        "duration": 5.44,
        "text": "this is very similar to those working"
      },
      {
        "start": 153.04,
        "duration": 6.08,
        "text": "with the cassandra components of dse"
      },
      {
        "start": 156.64,
        "duration": 3.12,
        "text": "choosing vertex labels especially in the"
      },
      {
        "start": 159.12,
        "duration": 3.36,
        "text": "presence of"
      },
      {
        "start": 159.76,
        "duration": 5.28,
        "text": "entity type hierarchies can affect graph"
      },
      {
        "start": 162.48,
        "duration": 4.96,
        "text": "partitioning in dsc graph"
      },
      {
        "start": 165.04,
        "duration": 4.32,
        "text": "underneath the cover dse graph creates"
      },
      {
        "start": 167.44,
        "duration": 4.159,
        "text": "two cassandra tables for each vertex"
      },
      {
        "start": 169.36,
        "duration": 4.48,
        "text": "label or type that is created"
      },
      {
        "start": 171.599,
        "duration": 3.92,
        "text": "these cassandra tables use a primary key"
      },
      {
        "start": 173.84,
        "duration": 2.8,
        "text": "that corresponds to the vertex"
      },
      {
        "start": 175.519,
        "duration": 3.521,
        "text": "identifier"
      },
      {
        "start": 176.64,
        "duration": 5.84,
        "text": "this means that vertex property and edge"
      },
      {
        "start": 179.04,
        "duration": 5.52,
        "text": "data is always stored together on a node"
      },
      {
        "start": 182.48,
        "duration": 4.16,
        "text": "and we can use cassandra's wide row"
      },
      {
        "start": 184.56,
        "duration": 2.56,
        "text": "partition and clustering keys to further"
      },
      {
        "start": 186.64,
        "duration": 3.28,
        "text": "control"
      },
      {
        "start": 187.12,
        "duration": 4.88,
        "text": "data placement in dse graph data"
      },
      {
        "start": 189.92,
        "duration": 4.72,
        "text": "placement is the central implementation"
      },
      {
        "start": 192.0,
        "duration": 5.36,
        "text": "concept of graph partitioning"
      },
      {
        "start": 194.64,
        "duration": 3.44,
        "text": "in dse graph this technique is named"
      },
      {
        "start": 197.36,
        "duration": 3.12,
        "text": "user-defined"
      },
      {
        "start": 198.08,
        "duration": 4.239,
        "text": "vertex ids it's worth mentioning in"
      },
      {
        "start": 200.48,
        "duration": 5.119,
        "text": "older versions of dse graph"
      },
      {
        "start": 202.319,
        "duration": 4.721,
        "text": "dsc graph used to generate ids for users"
      },
      {
        "start": 205.599,
        "duration": 3.041,
        "text": "this it turns out resulted in"
      },
      {
        "start": 207.04,
        "duration": 4.64,
        "text": "sub-optimal data placement and"
      },
      {
        "start": 208.64,
        "duration": 5.679,
        "text": "impacts a graph's ability to scale using"
      },
      {
        "start": 211.68,
        "duration": 4.479,
        "text": "user-defined vertex ids is a recommended"
      },
      {
        "start": 214.319,
        "duration": 3.2,
        "text": "approach for working with graphs in dsc"
      },
      {
        "start": 216.159,
        "duration": 3.36,
        "text": "graph"
      },
      {
        "start": 217.519,
        "duration": 3.761,
        "text": "we have three types of user-defined"
      },
      {
        "start": 219.519,
        "duration": 4.161,
        "text": "vertex ids"
      },
      {
        "start": 221.28,
        "duration": 3.039,
        "text": "the first is a vertex id based on a"
      },
      {
        "start": 223.68,
        "duration": 3.199,
        "text": "simple"
      },
      {
        "start": 224.319,
        "duration": 4.56,
        "text": "partitioning key structure this is the"
      },
      {
        "start": 226.879,
        "duration": 4.321,
        "text": "most basic implementation in which every"
      },
      {
        "start": 228.879,
        "duration": 4.321,
        "text": "new vertex is created using unique"
      },
      {
        "start": 231.2,
        "duration": 4.08,
        "text": "cassandra partitions"
      },
      {
        "start": 233.2,
        "duration": 3.84,
        "text": "cassandra will hash the partition key"
      },
      {
        "start": 235.28,
        "duration": 3.039,
        "text": "and store the data randomly throughout"
      },
      {
        "start": 237.04,
        "duration": 3.04,
        "text": "the cluster"
      },
      {
        "start": 238.319,
        "duration": 3.361,
        "text": "this is the easiest method of"
      },
      {
        "start": 240.08,
        "duration": 3.439,
        "text": "implementation that ensures an"
      },
      {
        "start": 241.68,
        "duration": 3.52,
        "text": "even distribution of your data across"
      },
      {
        "start": 243.519,
        "duration": 4.08,
        "text": "your cluster"
      },
      {
        "start": 245.2,
        "duration": 4.239,
        "text": "but this also doesn't provide users with"
      },
      {
        "start": 247.599,
        "duration": 3.601,
        "text": "any control over data placement or"
      },
      {
        "start": 249.439,
        "duration": 3.44,
        "text": "locality"
      },
      {
        "start": 251.2,
        "duration": 2.959,
        "text": "in other words this is the most"
      },
      {
        "start": 252.879,
        "duration": 2.56,
        "text": "simplistic approach to graph"
      },
      {
        "start": 254.159,
        "duration": 2.961,
        "text": "partitioning"
      },
      {
        "start": 255.439,
        "duration": 3.281,
        "text": "you could even say this is a graph"
      },
      {
        "start": 257.12,
        "duration": 3.76,
        "text": "without partitioning"
      },
      {
        "start": 258.72,
        "duration": 3.759,
        "text": "the next user defined vertex type is to"
      },
      {
        "start": 260.88,
        "duration": 3.92,
        "text": "use composite partition"
      },
      {
        "start": 262.479,
        "duration": 4.641,
        "text": "keys this means that instead of just"
      },
      {
        "start": 264.8,
        "duration": 4.64,
        "text": "using one property to identify a unique"
      },
      {
        "start": 267.12,
        "duration": 3.12,
        "text": "vertex two or more properties are used"
      },
      {
        "start": 269.44,
        "duration": 3.28,
        "text": "to identify"
      },
      {
        "start": 270.24,
        "duration": 4.239,
        "text": "a unique vertex the results of this"
      },
      {
        "start": 272.72,
        "duration": 3.68,
        "text": "approach are very similar to the simple"
      },
      {
        "start": 274.479,
        "duration": 4.081,
        "text": "partition key approach we described on"
      },
      {
        "start": 276.4,
        "duration": 4.56,
        "text": "the previous slide"
      },
      {
        "start": 278.56,
        "duration": 4.48,
        "text": "the only difference is here we can use"
      },
      {
        "start": 280.96,
        "duration": 3.12,
        "text": "more than one property key to identify"
      },
      {
        "start": 283.04,
        "duration": 3.68,
        "text": "our partitioning"
      },
      {
        "start": 284.08,
        "duration": 3.52,
        "text": "the final user-defined vertex id type is"
      },
      {
        "start": 286.72,
        "duration": 4.4,
        "text": "a vertex id"
      },
      {
        "start": 287.6,
        "duration": 5.44,
        "text": "using partition and clustering keys"
      },
      {
        "start": 291.12,
        "duration": 3.6,
        "text": "this method provides the most control"
      },
      {
        "start": 293.04,
        "duration": 2.96,
        "text": "over graph partitioning and enables"
      },
      {
        "start": 294.72,
        "duration": 3.44,
        "text": "graph users to achieve"
      },
      {
        "start": 296.0,
        "duration": 4.24,
        "text": "data locality by using the same"
      },
      {
        "start": 298.16,
        "duration": 4.0,
        "text": "partition key property to identify"
      },
      {
        "start": 300.24,
        "duration": 3.2,
        "text": "multiple vertices that belong to the"
      },
      {
        "start": 302.16,
        "duration": 3.28,
        "text": "same sub-graph"
      },
      {
        "start": 303.44,
        "duration": 4.319,
        "text": "this is the most powerful design pattern"
      },
      {
        "start": 305.44,
        "duration": 4.56,
        "text": "as it allows multiple vertices"
      },
      {
        "start": 307.759,
        "duration": 4.241,
        "text": "to reside in the same physical partition"
      },
      {
        "start": 310.0,
        "duration": 3.44,
        "text": "and share the same node"
      },
      {
        "start": 312.0,
        "duration": 3.28,
        "text": "here you can see that we have two"
      },
      {
        "start": 313.44,
        "duration": 2.96,
        "text": "vertices with a partition key of alice"
      },
      {
        "start": 315.28,
        "duration": 3.04,
        "text": "in wonderland"
      },
      {
        "start": 316.4,
        "duration": 3.84,
        "text": "it would be very efficient to retrieve"
      },
      {
        "start": 318.32,
        "duration": 4.64,
        "text": "all movies with a given title by simply"
      },
      {
        "start": 320.24,
        "duration": 4.48,
        "text": "traversing on the partition key only"
      },
      {
        "start": 322.96,
        "duration": 3.84,
        "text": "dse graph will translate these"
      },
      {
        "start": 324.72,
        "duration": 5.28,
        "text": "operations to cassandra partition"
      },
      {
        "start": 326.8,
        "duration": 5.6,
        "text": "axis patterns which are very efficient"
      },
      {
        "start": 330.0,
        "duration": 4.32,
        "text": "okay so you now see how we can use the"
      },
      {
        "start": 332.4,
        "duration": 3.84,
        "text": "power of cassandra's wide row data model"
      },
      {
        "start": 334.32,
        "duration": 2.879,
        "text": "to achieve a practical solution to graph"
      },
      {
        "start": 336.24,
        "duration": 2.56,
        "text": "partitioning"
      },
      {
        "start": 337.199,
        "duration": 2.881,
        "text": "give this exercise a go and we'll be"
      },
      {
        "start": 338.8,
        "duration": 7.44,
        "text": "right here when you're ready to learn"
      },
      {
        "start": 340.08,
        "duration": 6.16,
        "text": "more about dse graph"
      }
    ],
    "error": null,
    "error_type": null
  },
  "collected_at": "2025-12-15T22:54:40.942535+00:00"
}