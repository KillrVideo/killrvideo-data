{
  "video_id": "OCakxrzwuU4",
  "title": "DS201.04 Clustering Columns | Foundations of Apache Cassandra",
  "description": "#DataStaxAcademy #DS201\nDS201.04 CLUSTERING COLUMNS\n\nLEARN FOR FREE at https://academy.datastax.com -- access all the FREE complete courses, tutorials, and hands-on exercises.\n\nASK QUESTIONS at https://community.datastax.com -- where experts from DataStax & the Apache Cassandra community share their expertise everyday.",
  "published_at": "2020-08-06T03:50:43Z",
  "thumbnail": "https://i.ytimg.com/vi/OCakxrzwuU4/maxresdefault.jpg",
  "channel_title": "DataStax Developers",
  "channel_id": "UCAIQY251avaMv7bBv5PCo-A",
  "tags": [
    "cassandra",
    "datastax",
    "tutorial",
    "apache_cassandra"
  ],
  "url": "https://www.youtube.com/watch?v=OCakxrzwuU4",
  "transcript": {
    "available": true,
    "language": "Chinese",
    "language_code": "zh",
    "is_generated": false,
    "text": "  DS201.4: 聚类键（Clustering Columns） 让我们来探讨下聚类键 聚类键是主键(Primary Key)的第二部分 主键是你Cassandra数据模型最重要的一部分 现在我们已经讨论了分区键(Partition Keys) 聚类键是真正让主键能够行使功能的那个部分 他们都不是可选参数 你需要真正理解这些是怎么运作的  当你可以将分区键和聚类键同时搭配使用时 你将会有一个超赞的数据模型 现在让我们现一下这个将state（美国的“州”）作为分区键的表格 这会将这些state集合在一起 如果拿Texas（美国德克萨斯州）举例 这就意味着所有数据将会被放置在同一个文件、同一块硬盘、同一个节点 但是 state只是这些数据的唯一性所需的一部分 单单有state是不够的 同时我们也想控制下数据排列的顺序 就比如你在关系型数据库中使用GROUP BY 数据将按state列进行分组 但我们如何控制数据模型中的顺序和唯一性 现在主键控制着唯一性 但现在我们将city（市）作为聚类键 这意味着我们要用city来对所有在 Texas下的数据进行排序 在这个例子中 这是city的升序排列 所有这些在Texas的城市会按首字母a到z排列 所有这个分区的数据都会严格照此排列 这是一个按city排列的顺序 但如果我们想要用其他的列来排序呢 比如说name（名字）？ 我们这里有些很赞的名字 我也想用它们来排序 如Lone Star、Compact One  又或者是我的昵称Dev Awesome 因此  如果我们想这样做 我们必须要改变主键 但是 已有的数据模型了的键是无法被改变的 谨慎地说 你无法命令一个数据模型说：”我想改数据库表(ALTER TABLE)、改变主键、添加字段名“ 这是在你插入数据之前就应该完成的事情 如果你数据库中已经有数据了 在没有重建一个新的数据模型的情况下 你是无法修改主键的 我就想确保我在这里已经提醒过了 但在这个的案例中 我已经将state和name作为主键 现在会按name排序 就如你现在看到的 我们现在按name排序 state是分区键 这说明所有数据已经按组分好类了 在这里city不是那么重要了   因为我们并不需要按city分类 但是我们可以在此将它添加为聚类键 聚类键总是紧接在分区键之后 你可以根据需求设置一个、多个或很多很多个也可以 这只关系到你需要在数据库中添加多少条件来实现唯一性并控制排序 因此主键在这里也变得非常非常重要 在这里我们不止添加了city但也加了name 意思就是先按city排序 之后再按name排序 现在我们有了一个排序简洁的数据库 而且它可能和应用程序协作良好 我们的查询语句也许需要既根据city又根据name排序 而我们已经提前将这些信息进行排序了 所以设置好聚类键之后 当我们往数据库中插入数据时 它会以相同的顺序将数据储存在硬盘中 因此数据是提前优化过的 并且查询速度非常快 这真的很方便 等下 那这样就会有一个问题 现在的问题是city的名字已经不够唯一识别数据了 会有很多人住在一个美国的state中 也可能会有很多同名的人住在同一个城市 如果我们创建了一个由state、city、name组成的主键 你会遇到冲突 Cassandra没法通过唯一性来处理这种情况 因此你会碰到这样的情景 当你在数据库中插入数据时 数据库会覆写已有的数据 但这并不是你想要的 那在表中加入一些能创造唯一性的东西如何 在这里我们添加了id 这是我们自行添加的id 在Cassandra数据库中没有能自动递增的值 我知道很多关系式数据库是有的 但这要在分布式数据库里实现是很困难的 在这里我们使用了整数(integer)类型 这个字段的引入让我们实现了记录的唯一性 最终每条数据同时含有state、city、name和一个独特的值 所以 结合起来说 这些所有的放在一起组成了一条具有唯一性的记录 我们可以保证没有任何的冲突 现在有很多可以避免冲突的技巧 这只是一个很简单的案例 但这给你了一个避免这种问题的思路 在这里主键解决了两个问题 记录的唯一性和数据顺序的控制 不过其实你可以进一步地控制顺序 现在我们已经有了很赞的主键 我们还可以在查询语句中使用ORDER BY 来改变数据的顺序 因此 不止当你插入数据时 在执行SELECT语句时 你也可以获取不同的排列顺序 比如 当你执行一条按state或name的查询语句时 它会针对ORDER BY指令进行优化 可能你已经注意到state外面有个括号 也许你会好奇为什么 因为那是分区键的一部分 当只有一个分区键时 括号是可有可无的 然而 如果你有多个分区键 就必须要加括号了 这个问题会在之后的视频中讲到 既然已经提到了查询语句 让我们再说说这个问题 关于我们能利用查询语句做什么 无论何时 当你在使用一个含有分区键和聚类键的主键时  每一个键在你的查询中都是独特且有用的 首先 所有的查询语句应该都要有一个分区键 原因是你得在你的集群中找到特定的数据 如果你没有提供分区键 你得集群中随机查找数据 你不会想要这么做的 想要直接去找这条数据？ 也许这也不是一个好的主意 我们想要很具体地查询 这也为什么分区键是十分重要的 当具体到某一个分区时 你可以做一些比较精细的筛选 如 等于、大于、小于  任何不等式查询 在同一分区范围内都是被允许的 同时聚类键的顺序也十分的重要 如果你要用等号来查询某些特定的数据 你必须要按聚类键在主键中的排序来指定聚类键的值 在聚类键是state、city、name的情况下 如果你想进行等号查询 你可以写  ”state = texas, city = austin\" 然后数据库会给你所有符合要求的数据 如果你写 ”state = texas“ 然后写比如 “name = dev awesome\"  那样是行不通的 因为你将name放到了city前面  这样就没有遵守主键中聚类键的顺序 如果你执行这样的查询  Cassandra会返回一个错误信息说：你没有按照聚类键的顺序正确查询 你只需要知道那是什么意思 知道你必须要遵循聚类键的顺序进行查询 因为这样做将会使你的查询语句在提取数据时变得很高效 现在当我们在通过这些查询语句进行搜索时 我们实际上已经提前做好了要在硬盘上的操作 仰赖于我们的数据模型 其中的数据已经以某种方式排序好了 这样它可以在硬盘上利用二分法检索 这样的数据模型就会变得非常之快 那如果我们想改变查询结果的排序呢？ 无论何时 当我们创建一个包含聚类键的主键时 默认的排序方式是升序 如果这并不是你需要的呢 我们可以在你的数据模型中添加一条子句 CLUSTERING ORDER BY 你可以使用它来控制聚类键的查询结果的顺序 从升序到降序 这在某些使用情景下会创造很多方便 比如一个时间序列的数据模型 与一个升序的数据模型相比 你会更想要一个降序的数据模型 这意味着最近发生的事情会在你数据的第一行 CLUSTERING ORDER BY在某种使用情境下是十分有用的 比如时间序列 时间序列可以让你修改时间数据的顺序 比如你用DATE或者TIMEUUID这些数据类型 它将允许你将数据以相反的顺序储存在硬盘上 这样一来 时序越新的数据会越处于数据模型前面的部分 因此你总是会先看到最新的数据 这将会是一件非常方便的事情 尤其是对于对运行速度有要求的程序 如银行欺诈检测 同时 这也是你可以早在插入数据之前就控制的事情 这会让数据库变得非常高效 比如 当你输入SELECT *  FROM USER 时 这在关系型数据库中看起来是一个很合理的查询语句 我只是想提取所有的用户数据 但如果对于像Cassandra这样的 有多个节点并且分散在不同地区的大型数据库而言 这可能是你能写出的最差的查询语句之一 因为你这样做就相当于告诉系统  去每一个节点 给我提取每一条在系统中的数据 这不是一个好主意 因此 数据库这时可能会提示你：可能你应该要用ALLOW FILTERING 打住 如果你真以为那是你需要的 那可能你就错了 因为ALLOW FILTERING只适用于一些非常特殊的用例 在不得不的情况下 它让人们进行全局搜索 如果你觉得你的数据库模型需要ALLOW FILTERING 请再三思考 也许事实上并非如此 不过你要知道ALLOW FILTERING是做什么的 当你真的使用它时 请睁大眼睛 现在让我们做一个有关聚类键的练习 这样你可以真正的体会到它是怎么使用的",
    "segments": [
      {
        "start": 0.0,
        "duration": 6.542,
        "text": "  DS201.4: 聚类键（Clustering Columns）"
      },
      {
        "start": 6.542,
        "duration": 2.319,
        "text": "让我们来探讨下聚类键"
      },
      {
        "start": 8.861,
        "duration": 4.509,
        "text": "聚类键是主键(Primary Key)的第二部分"
      },
      {
        "start": 13.37,
        "duration": 3.88,
        "text": "主键是你Cassandra数据模型最重要的一部分"
      },
      {
        "start": 17.25,
        "duration": 1.822,
        "text": "现在我们已经讨论了分区键(Partition Keys)"
      },
      {
        "start": 19.072,
        "duration": 4.033,
        "text": "聚类键是真正让主键能够行使功能的那个部分"
      },
      {
        "start": 23.105,
        "duration": 1.683,
        "text": "他们都不是可选参数"
      },
      {
        "start": 24.788,
        "duration": 2.014,
        "text": "你需要真正理解这些是怎么运作的"
      },
      {
        "start": 26.802,
        "duration": 4.723,
        "text": " 当你可以将分区键和聚类键同时搭配使用时"
      },
      {
        "start": 31.525,
        "duration": 2.225,
        "text": "你将会有一个超赞的数据模型"
      },
      {
        "start": 33.75,
        "duration": 3.25,
        "text": "现在让我们现一下这个将state（美国的“州”）作为分区键的表格"
      },
      {
        "start": 37.0,
        "duration": 3.139,
        "text": "这会将这些state集合在一起"
      },
      {
        "start": 40.139,
        "duration": 2.003,
        "text": "如果拿Texas（美国德克萨斯州）举例"
      },
      {
        "start": 42.142,
        "duration": 5.051,
        "text": "这就意味着所有数据将会被放置在同一个文件、同一块硬盘、同一个节点"
      },
      {
        "start": 47.193,
        "duration": 0.579,
        "text": "但是"
      },
      {
        "start": 47.772,
        "duration": 4.313,
        "text": "state只是这些数据的唯一性所需的一部分"
      },
      {
        "start": 52.085,
        "duration": 1.703,
        "text": "单单有state是不够的"
      },
      {
        "start": 53.788,
        "duration": 1.773,
        "text": "同时我们也想控制下数据排列的顺序"
      },
      {
        "start": 55.561,
        "duration": 3.402,
        "text": "就比如你在关系型数据库中使用GROUP BY"
      },
      {
        "start": 58.963,
        "duration": 1.944,
        "text": "数据将按state列进行分组"
      },
      {
        "start": 60.907,
        "duration": 3.887,
        "text": "但我们如何控制数据模型中的顺序和唯一性"
      },
      {
        "start": 64.794,
        "duration": 3.864,
        "text": "现在主键控制着唯一性"
      },
      {
        "start": 68.658,
        "duration": 3.133,
        "text": "但现在我们将city（市）作为聚类键"
      },
      {
        "start": 71.791,
        "duration": 6.488,
        "text": "这意味着我们要用city来对所有在 Texas下的数据进行排序"
      },
      {
        "start": 78.279,
        "duration": 3.849,
        "text": "在这个例子中 这是city的升序排列"
      },
      {
        "start": 82.128,
        "duration": 3.743,
        "text": "所有这些在Texas的城市会按首字母a到z排列"
      },
      {
        "start": 85.871,
        "duration": 2.5,
        "text": "所有这个分区的数据都会严格照此排列"
      },
      {
        "start": 88.371,
        "duration": 2.277,
        "text": "这是一个按city排列的顺序"
      },
      {
        "start": 90.648,
        "duration": 3.415,
        "text": "但如果我们想要用其他的列来排序呢 比如说name（名字）？"
      },
      {
        "start": 94.063,
        "duration": 3.464,
        "text": "我们这里有些很赞的名字 我也想用它们来排序"
      },
      {
        "start": 97.527,
        "duration": 2.473,
        "text": "如Lone Star、Compact One "
      },
      {
        "start": 100.0,
        "duration": 2.104,
        "text": "又或者是我的昵称Dev Awesome"
      },
      {
        "start": 102.104,
        "duration": 1.111,
        "text": "因此 "
      },
      {
        "start": 103.215,
        "duration": 2.453,
        "text": "如果我们想这样做 我们必须要改变主键"
      },
      {
        "start": 105.668,
        "duration": 4.091,
        "text": "但是 已有的数据模型了的键是无法被改变的"
      },
      {
        "start": 109.759,
        "duration": 1.428,
        "text": "谨慎地说"
      },
      {
        "start": 111.187,
        "duration": 5.674,
        "text": "你无法命令一个数据模型说：”我想改数据库表(ALTER TABLE)、改变主键、添加字段名“"
      },
      {
        "start": 116.861,
        "duration": 2.975,
        "text": "这是在你插入数据之前就应该完成的事情"
      },
      {
        "start": 119.836,
        "duration": 2.0,
        "text": "如果你数据库中已经有数据了"
      },
      {
        "start": 121.836,
        "duration": 3.098,
        "text": "在没有重建一个新的数据模型的情况下 你是无法修改主键的"
      },
      {
        "start": 124.934,
        "duration": 2.201,
        "text": "我就想确保我在这里已经提醒过了"
      },
      {
        "start": 127.135,
        "duration": 2.357,
        "text": "但在这个的案例中"
      },
      {
        "start": 129.492,
        "duration": 3.187,
        "text": "我已经将state和name作为主键"
      },
      {
        "start": 132.679,
        "duration": 2.806,
        "text": "现在会按name排序"
      },
      {
        "start": 135.485,
        "duration": 2.833,
        "text": "就如你现在看到的 我们现在按name排序"
      },
      {
        "start": 138.318,
        "duration": 4.623,
        "text": "state是分区键 这说明所有数据已经按组分好类了"
      },
      {
        "start": 142.941,
        "duration": 2.658,
        "text": "在这里city不是那么重要了  "
      },
      {
        "start": 145.599,
        "duration": 2.546,
        "text": "因为我们并不需要按city分类"
      },
      {
        "start": 148.145,
        "duration": 3.855,
        "text": "但是我们可以在此将它添加为聚类键"
      },
      {
        "start": 152.0,
        "duration": 4.387,
        "text": "聚类键总是紧接在分区键之后"
      },
      {
        "start": 156.387,
        "duration": 4.637,
        "text": "你可以根据需求设置一个、多个或很多很多个也可以"
      },
      {
        "start": 161.024,
        "duration": 3.32,
        "text": "这只关系到你需要在数据库中添加多少条件来实现唯一性并控制排序"
      },
      {
        "start": 164.344,
        "duration": 3.609,
        "text": "因此主键在这里也变得非常非常重要"
      },
      {
        "start": 167.953,
        "duration": 3.779,
        "text": "在这里我们不止添加了city但也加了name"
      },
      {
        "start": 171.732,
        "duration": 2.814,
        "text": "意思就是先按city排序"
      },
      {
        "start": 174.546,
        "duration": 2.122,
        "text": "之后再按name排序"
      },
      {
        "start": 176.668,
        "duration": 5.287,
        "text": "现在我们有了一个排序简洁的数据库 而且它可能和应用程序协作良好"
      },
      {
        "start": 181.955,
        "duration": 4.77,
        "text": "我们的查询语句也许需要既根据city又根据name排序"
      },
      {
        "start": 186.725,
        "duration": 2.383,
        "text": "而我们已经提前将这些信息进行排序了"
      },
      {
        "start": 189.108,
        "duration": 2.0,
        "text": "所以设置好聚类键之后"
      },
      {
        "start": 191.108,
        "duration": 2.748,
        "text": "当我们往数据库中插入数据时"
      },
      {
        "start": 193.856,
        "duration": 2.695,
        "text": "它会以相同的顺序将数据储存在硬盘中"
      },
      {
        "start": 196.551,
        "duration": 2.879,
        "text": "因此数据是提前优化过的 并且查询速度非常快"
      },
      {
        "start": 199.43,
        "duration": 1.188,
        "text": "这真的很方便"
      },
      {
        "start": 200.618,
        "duration": 2.424,
        "text": "等下 那这样就会有一个问题"
      },
      {
        "start": 203.427,
        "duration": 3.924,
        "text": "现在的问题是city的名字已经不够唯一识别数据了"
      },
      {
        "start": 207.351,
        "duration": 5.09,
        "text": "会有很多人住在一个美国的state中"
      },
      {
        "start": 212.441,
        "duration": 3.376,
        "text": "也可能会有很多同名的人住在同一个城市"
      },
      {
        "start": 215.817,
        "duration": 3.756,
        "text": "如果我们创建了一个由state、city、name组成的主键"
      },
      {
        "start": 219.573,
        "duration": 1.887,
        "text": "你会遇到冲突"
      },
      {
        "start": 221.46,
        "duration": 3.15,
        "text": "Cassandra没法通过唯一性来处理这种情况"
      },
      {
        "start": 224.61,
        "duration": 1.756,
        "text": "因此你会碰到这样的情景"
      },
      {
        "start": 226.366,
        "duration": 1.711,
        "text": "当你在数据库中插入数据时"
      },
      {
        "start": 228.077,
        "duration": 3.073,
        "text": "数据库会覆写已有的数据 但这并不是你想要的"
      },
      {
        "start": 231.15,
        "duration": 3.884,
        "text": "那在表中加入一些能创造唯一性的东西如何"
      },
      {
        "start": 235.034,
        "duration": 2.383,
        "text": "在这里我们添加了id"
      },
      {
        "start": 237.417,
        "duration": 2.583,
        "text": "这是我们自行添加的id"
      },
      {
        "start": 240.0,
        "duration": 3.558,
        "text": "在Cassandra数据库中没有能自动递增的值"
      },
      {
        "start": 243.558,
        "duration": 2.016,
        "text": "我知道很多关系式数据库是有的"
      },
      {
        "start": 245.574,
        "duration": 3.218,
        "text": "但这要在分布式数据库里实现是很困难的"
      },
      {
        "start": 248.809,
        "duration": 1.588,
        "text": "在这里我们使用了整数(integer)类型"
      },
      {
        "start": 250.397,
        "duration": 1.974,
        "text": "这个字段的引入让我们实现了记录的唯一性"
      },
      {
        "start": 252.371,
        "duration": 4.028,
        "text": "最终每条数据同时含有state、city、name和一个独特的值"
      },
      {
        "start": 256.399,
        "duration": 1.367,
        "text": "所以 结合起来说"
      },
      {
        "start": 257.766,
        "duration": 2.234,
        "text": "这些所有的放在一起组成了一条具有唯一性的记录"
      },
      {
        "start": 260.0,
        "duration": 2.542,
        "text": "我们可以保证没有任何的冲突"
      },
      {
        "start": 262.542,
        "duration": 3.416,
        "text": "现在有很多可以避免冲突的技巧"
      },
      {
        "start": 265.958,
        "duration": 1.747,
        "text": "这只是一个很简单的案例"
      },
      {
        "start": 267.705,
        "duration": 3.272,
        "text": "但这给你了一个避免这种问题的思路"
      },
      {
        "start": 270.977,
        "duration": 2.802,
        "text": "在这里主键解决了两个问题"
      },
      {
        "start": 273.779,
        "duration": 3.167,
        "text": "记录的唯一性和数据顺序的控制"
      },
      {
        "start": 276.946,
        "duration": 2.264,
        "text": "不过其实你可以进一步地控制顺序"
      },
      {
        "start": 279.21,
        "duration": 2.646,
        "text": "现在我们已经有了很赞的主键"
      },
      {
        "start": 281.856,
        "duration": 3.57,
        "text": "我们还可以在查询语句中使用ORDER BY"
      },
      {
        "start": 285.426,
        "duration": 1.684,
        "text": "来改变数据的顺序"
      },
      {
        "start": 287.11,
        "duration": 2.89,
        "text": "因此 不止当你插入数据时"
      },
      {
        "start": 290.0,
        "duration": 5.0,
        "text": "在执行SELECT语句时 你也可以获取不同的排列顺序"
      },
      {
        "start": 295.0,
        "duration": 4.772,
        "text": "比如 当你执行一条按state或name的查询语句时"
      },
      {
        "start": 299.772,
        "duration": 2.0,
        "text": "它会针对ORDER BY指令进行优化"
      },
      {
        "start": 301.772,
        "duration": 3.917,
        "text": "可能你已经注意到state外面有个括号"
      },
      {
        "start": 305.689,
        "duration": 2.0,
        "text": "也许你会好奇为什么"
      },
      {
        "start": 307.689,
        "duration": 2.0,
        "text": "因为那是分区键的一部分"
      },
      {
        "start": 309.689,
        "duration": 4.44,
        "text": "当只有一个分区键时 括号是可有可无的"
      },
      {
        "start": 314.129,
        "duration": 3.98,
        "text": "然而 如果你有多个分区键 就必须要加括号了"
      },
      {
        "start": 318.109,
        "duration": 2.683,
        "text": "这个问题会在之后的视频中讲到"
      },
      {
        "start": 320.792,
        "duration": 1.671,
        "text": "既然已经提到了查询语句"
      },
      {
        "start": 322.463,
        "duration": 1.408,
        "text": "让我们再说说这个问题"
      },
      {
        "start": 323.871,
        "duration": 1.599,
        "text": "关于我们能利用查询语句做什么"
      },
      {
        "start": 325.47,
        "duration": 3.822,
        "text": "无论何时 当你在使用一个含有分区键和聚类键的主键时 "
      },
      {
        "start": 329.292,
        "duration": 3.0,
        "text": "每一个键在你的查询中都是独特且有用的"
      },
      {
        "start": 332.314,
        "duration": 3.429,
        "text": "首先 所有的查询语句应该都要有一个分区键"
      },
      {
        "start": 335.743,
        "duration": 4.274,
        "text": "原因是你得在你的集群中找到特定的数据"
      },
      {
        "start": 340.017,
        "duration": 2.158,
        "text": "如果你没有提供分区键"
      },
      {
        "start": 342.175,
        "duration": 3.41,
        "text": "你得集群中随机查找数据 你不会想要这么做的"
      },
      {
        "start": 345.585,
        "duration": 2.0,
        "text": "想要直接去找这条数据？"
      },
      {
        "start": 347.585,
        "duration": 1.523,
        "text": "也许这也不是一个好的主意"
      },
      {
        "start": 349.108,
        "duration": 3.411,
        "text": "我们想要很具体地查询 这也为什么分区键是十分重要的"
      },
      {
        "start": 352.519,
        "duration": 3.548,
        "text": "当具体到某一个分区时 你可以做一些比较精细的筛选"
      },
      {
        "start": 356.067,
        "duration": 2.655,
        "text": "如 等于、大于、小于 "
      },
      {
        "start": 358.722,
        "duration": 4.387,
        "text": "任何不等式查询 在同一分区范围内都是被允许的"
      },
      {
        "start": 363.109,
        "duration": 3.842,
        "text": "同时聚类键的顺序也十分的重要"
      },
      {
        "start": 366.951,
        "duration": 3.443,
        "text": "如果你要用等号来查询某些特定的数据"
      },
      {
        "start": 370.394,
        "duration": 4.216,
        "text": "你必须要按聚类键在主键中的排序来指定聚类键的值"
      },
      {
        "start": 374.61,
        "duration": 4.096,
        "text": "在聚类键是state、city、name的情况下"
      },
      {
        "start": 378.706,
        "duration": 1.874,
        "text": "如果你想进行等号查询 你可以写"
      },
      {
        "start": 380.58,
        "duration": 3.288,
        "text": " ”state = texas, city = austin\""
      },
      {
        "start": 383.868,
        "duration": 2.508,
        "text": "然后数据库会给你所有符合要求的数据"
      },
      {
        "start": 386.376,
        "duration": 2.508,
        "text": "如果你写 ”state = texas“"
      },
      {
        "start": 388.884,
        "duration": 3.324,
        "text": "然后写比如 “name = dev awesome\" "
      },
      {
        "start": 392.208,
        "duration": 1.181,
        "text": "那样是行不通的"
      },
      {
        "start": 393.389,
        "duration": 4.23,
        "text": "因为你将name放到了city前面 "
      },
      {
        "start": 397.619,
        "duration": 2.881,
        "text": "这样就没有遵守主键中聚类键的顺序"
      },
      {
        "start": 400.5,
        "duration": 2.368,
        "text": "如果你执行这样的查询 "
      },
      {
        "start": 402.868,
        "duration": 4.632,
        "text": "Cassandra会返回一个错误信息说：你没有按照聚类键的顺序正确查询"
      },
      {
        "start": 407.5,
        "duration": 1.74,
        "text": "你只需要知道那是什么意思"
      },
      {
        "start": 409.24,
        "duration": 2.817,
        "text": "知道你必须要遵循聚类键的顺序进行查询"
      },
      {
        "start": 412.057,
        "duration": 4.56,
        "text": "因为这样做将会使你的查询语句在提取数据时变得很高效"
      },
      {
        "start": 416.617,
        "duration": 2.799,
        "text": "现在当我们在通过这些查询语句进行搜索时"
      },
      {
        "start": 419.416,
        "duration": 2.792,
        "text": "我们实际上已经提前做好了要在硬盘上的操作"
      },
      {
        "start": 422.208,
        "duration": 3.696,
        "text": "仰赖于我们的数据模型 其中的数据已经以某种方式排序好了"
      },
      {
        "start": 425.904,
        "duration": 2.697,
        "text": "这样它可以在硬盘上利用二分法检索"
      },
      {
        "start": 428.601,
        "duration": 2.958,
        "text": "这样的数据模型就会变得非常之快"
      },
      {
        "start": 431.559,
        "duration": 2.983,
        "text": "那如果我们想改变查询结果的排序呢？"
      },
      {
        "start": 434.542,
        "duration": 3.708,
        "text": "无论何时 当我们创建一个包含聚类键的主键时"
      },
      {
        "start": 438.25,
        "duration": 3.352,
        "text": "默认的排序方式是升序"
      },
      {
        "start": 441.602,
        "duration": 1.373,
        "text": "如果这并不是你需要的呢"
      },
      {
        "start": 442.975,
        "duration": 2.523,
        "text": "我们可以在你的数据模型中添加一条子句"
      },
      {
        "start": 445.498,
        "duration": 1.46,
        "text": "CLUSTERING ORDER BY"
      },
      {
        "start": 446.958,
        "duration": 3.568,
        "text": "你可以使用它来控制聚类键的查询结果的顺序"
      },
      {
        "start": 450.526,
        "duration": 2.627,
        "text": "从升序到降序"
      },
      {
        "start": 453.153,
        "duration": 2.673,
        "text": "这在某些使用情景下会创造很多方便"
      },
      {
        "start": 455.826,
        "duration": 2.356,
        "text": "比如一个时间序列的数据模型"
      },
      {
        "start": 458.182,
        "duration": 4.561,
        "text": "与一个升序的数据模型相比 你会更想要一个降序的数据模型"
      },
      {
        "start": 462.743,
        "duration": 3.929,
        "text": "这意味着最近发生的事情会在你数据的第一行"
      },
      {
        "start": 466.672,
        "duration": 4.143,
        "text": "CLUSTERING ORDER BY在某种使用情境下是十分有用的"
      },
      {
        "start": 470.815,
        "duration": 2.153,
        "text": "比如时间序列"
      },
      {
        "start": 472.968,
        "duration": 3.07,
        "text": "时间序列可以让你修改时间数据的顺序"
      },
      {
        "start": 476.038,
        "duration": 3.625,
        "text": "比如你用DATE或者TIMEUUID这些数据类型"
      },
      {
        "start": 479.663,
        "duration": 3.379,
        "text": "它将允许你将数据以相反的顺序储存在硬盘上"
      },
      {
        "start": 483.042,
        "duration": 3.472,
        "text": "这样一来 时序越新的数据会越处于数据模型前面的部分"
      },
      {
        "start": 486.514,
        "duration": 2.767,
        "text": "因此你总是会先看到最新的数据"
      },
      {
        "start": 489.281,
        "duration": 2.466,
        "text": "这将会是一件非常方便的事情"
      },
      {
        "start": 491.747,
        "duration": 4.143,
        "text": "尤其是对于对运行速度有要求的程序 如银行欺诈检测"
      },
      {
        "start": 495.89,
        "duration": 4.266,
        "text": "同时 这也是你可以早在插入数据之前就控制的事情"
      },
      {
        "start": 500.156,
        "duration": 1.599,
        "text": "这会让数据库变得非常高效"
      },
      {
        "start": 501.755,
        "duration": 4.788,
        "text": "比如 当你输入SELECT *  FROM USER 时"
      },
      {
        "start": 506.543,
        "duration": 3.301,
        "text": "这在关系型数据库中看起来是一个很合理的查询语句"
      },
      {
        "start": 509.844,
        "duration": 1.758,
        "text": "我只是想提取所有的用户数据"
      },
      {
        "start": 511.602,
        "duration": 2.68,
        "text": "但如果对于像Cassandra这样的"
      },
      {
        "start": 514.282,
        "duration": 3.374,
        "text": "有多个节点并且分散在不同地区的大型数据库而言"
      },
      {
        "start": 517.656,
        "duration": 2.691,
        "text": "这可能是你能写出的最差的查询语句之一"
      },
      {
        "start": 520.347,
        "duration": 2.349,
        "text": "因为你这样做就相当于告诉系统 "
      },
      {
        "start": 522.696,
        "duration": 4.013,
        "text": "去每一个节点 给我提取每一条在系统中的数据"
      },
      {
        "start": 526.709,
        "duration": 1.146,
        "text": "这不是一个好主意"
      },
      {
        "start": 527.855,
        "duration": 4.753,
        "text": "因此 数据库这时可能会提示你：可能你应该要用ALLOW FILTERING"
      },
      {
        "start": 532.608,
        "duration": 4.415,
        "text": "打住 如果你真以为那是你需要的 那可能你就错了"
      },
      {
        "start": 537.023,
        "duration": 3.885,
        "text": "因为ALLOW FILTERING只适用于一些非常特殊的用例"
      },
      {
        "start": 540.908,
        "duration": 4.756,
        "text": "在不得不的情况下 它让人们进行全局搜索"
      },
      {
        "start": 545.664,
        "duration": 2.554,
        "text": "如果你觉得你的数据库模型需要ALLOW FILTERING"
      },
      {
        "start": 548.218,
        "duration": 2.105,
        "text": "请再三思考 也许事实上并非如此"
      },
      {
        "start": 550.323,
        "duration": 2.0,
        "text": "不过你要知道ALLOW FILTERING是做什么的"
      },
      {
        "start": 552.323,
        "duration": 2.386,
        "text": "当你真的使用它时 请睁大眼睛"
      },
      {
        "start": 554.709,
        "duration": 2.929,
        "text": "现在让我们做一个有关聚类键的练习"
      },
      {
        "start": 557.638,
        "duration": 2.237,
        "text": "这样你可以真正的体会到它是怎么使用的"
      }
    ],
    "error": null,
    "error_type": null
  },
  "collected_at": "2025-12-16T02:08:47.558285+00:00"
}