{
  "video_id": "1cILfRBEmOU",
  "title": "DS332.03 Introduction to DSE GraphFrames | DataStax Enterprise 6 Graph Analytics",
  "description": "#DataStaxAcademy #DS332\nDS332.03 Introduction to DSE GraphFrames\nIn this unit, you will be introduced to DSE GraphFrames. DSE GraphFrames is an alternative OLAP engine for DataStax Enterprise Graph. It is designed around our DataStax Enterprise Analytics offering and it enables a unique way of interacting with DataStax Enterprise Graph using various Spark APIs and tools.\n\nLEARN FOR FREE at https://academy.datastax.com -- access all the FREE complete courses, tutorials, and hands-on exercises.\n\nASK QUESTIONS at https://community.datastax.com -- where experts from DataStax & the Apache Cassandra community share their expertise everyday.",
  "published_at": "2020-08-16T00:38:39Z",
  "thumbnail": "https://i.ytimg.com/vi/1cILfRBEmOU/maxresdefault.jpg",
  "channel_title": "DataStax Developers",
  "channel_id": "UCAIQY251avaMv7bBv5PCo-A",
  "tags": [
    "cassandra",
    "tutorial",
    "apache_cassandra",
    "introduction",
    "dse",
    "datastax"
  ],
  "url": "https://www.youtube.com/watch?v=1cILfRBEmOU",
  "transcript": {
    "available": true,
    "language": "English (auto-generated)",
    "language_code": "en",
    "is_generated": true,
    "text": "[Music] hi i am martim chibatko and this is introduction to dac graph frames dc graph frames is an alternative olap engine for dac graph it is designed around our dc analytics offering and it enables a unique way of interacting with dsc graph using various spark apis and tools you can think about a dac graph frame as a representation of your graph in spark and this representation is actually based on the original notion of graph frames in spark we will soon learn more about specifics of dac graph frame based on our killer video graph example there are various ways you can work with the dac graph frames you can use a subset of gremlin to define a lab graph traversals there is also a complementary dac graph frame api that is primarily used for bulk mutations you can search for structural graph patterns using the original spar graph frame api finally you can use any other spark api that may be suitable for your application that includes spark sql data frames and spark streaming just to name a few when it comes to dec graph frame use cases there are many you the versatility and power of this olap engine of course you can do gremlin traversals just like in the other alarm traversal engine based on the spar graph computer but these segre frames are unique as they also support non-gremlin graph data manipulation and accessing data directly from spark as a result you can combine data stored in dsa graph with data stored in cassandra with data stored in the relational database with data stored in a file with data coming in a stream and so forth and so on with this kind of power there are virtually unlimited possibilities for the type of analysis you may need it is also worth mentioning that dac graph frame is currently the most efficient way to do bulk loading and bulk mutations in dc graph if you have an existing graph data set that you want to load into dsc graph the ec graph frames is the way to go let's create our first dac graph frame in spark shell to do that we start spark shell by executing command dsc spark and then call the dsc graph method of the spark session object with the name of the graph as a parameter killer video in this case we assign the result to g which is an instance of the ac graph frame as you can see in the output while it is convenient to think about a dac graph frame as simply a representation of a graph stored in dsc graph there is a bit more to it internally in spark a dac graph frame is represented by two virtual tables or data frames one for vertices and one for edges the vertex data frame has columns for vertex id label and properties the h data frame has columns for source and destination vertex ids edge internal id label and properties it is important to notice that even so vertex ids in dc graph can be composed of values from multiple properties the dsa graph frame representation always serializes a vertex id as a single value through hashing and concatenation this is done on purpose to make the dsc graph frame format fully compatible with the original spark graph frame format so that you can take a full advantage of various spark apis in general this id conversion is done implicitly and automatically but we will also learn how to do it explicitly which will be useful in some cases in the context of our kilo video graph this is how the vertex table schema looks like g is our dsc graph frame we call its method v to get the vertex data frame and then data frames matter print schema to output the result we see columns id label user id age gender genre id name person id movie id and so forth the production column is a bit unique as it corresponds to a multi-property and its data type is the array of strings based on the columns you can see that this data frame is used for vertices of different types in our case users movies people and genres using data frames meta show we can take a look at the actual column values in the first five rows we have rows corresponding to user u185 genre adventure person johnny depp and two alice in wonderland movies similarly we can output the age data frame schema for the kili video graph it does look simpler because we only have one edge property called rating and it is of type int and you may remember that source and destination are columns that store age source and destination vertex ids an id is a column that stores hids that are generated and used internally by dsc graph here are some concrete values to look at besides the label and rating there is not much for us to comprehend finally we conclude this presentation with the summary of the ec graph frame apis that we cover in more detail in subsequent videos first we have gremlin api to define gremlin traversals starting with either method v or method e followed by traversal steps like in out count and so on we assume that you are already familiar with the gremlin traversal language second there is spar graph frame api that among other things has some interesting structural pattern matching capabilities in scholar the esc graph frame is converted to spar graph frame implicitly explicit conversion is done using the gf method third we have very efficient methods for bulk mutations we can insert update and delete graph elements with those and last but not least we have the data persistent methods cache and persist which you may already be familiar with since they have the same purpose as similar methods available in spark",
    "segments": [
      {
        "start": 1.42,
        "duration": 3.2,
        "text": "[Music]"
      },
      {
        "start": 5.279,
        "duration": 2.161,
        "text": "hi"
      },
      {
        "start": 5.759,
        "duration": 3.92,
        "text": "i am martim chibatko and this is"
      },
      {
        "start": 7.44,
        "duration": 4.72,
        "text": "introduction to dac graph frames"
      },
      {
        "start": 9.679,
        "duration": 4.0,
        "text": "dc graph frames is an alternative olap"
      },
      {
        "start": 12.16,
        "duration": 4.08,
        "text": "engine for dac graph"
      },
      {
        "start": 13.679,
        "duration": 3.121,
        "text": "it is designed around our dc analytics"
      },
      {
        "start": 16.24,
        "duration": 2.879,
        "text": "offering"
      },
      {
        "start": 16.8,
        "duration": 4.16,
        "text": "and it enables a unique way of"
      },
      {
        "start": 19.119,
        "duration": 4.881,
        "text": "interacting with dsc graph"
      },
      {
        "start": 20.96,
        "duration": 5.36,
        "text": "using various spark apis and tools you"
      },
      {
        "start": 24.0,
        "duration": 4.88,
        "text": "can think about a dac graph frame"
      },
      {
        "start": 26.32,
        "duration": 3.44,
        "text": "as a representation of your graph in"
      },
      {
        "start": 28.88,
        "duration": 2.719,
        "text": "spark"
      },
      {
        "start": 29.76,
        "duration": 4.24,
        "text": "and this representation is actually"
      },
      {
        "start": 31.599,
        "duration": 3.841,
        "text": "based on the original notion of graph"
      },
      {
        "start": 34.0,
        "duration": 3.52,
        "text": "frames in spark"
      },
      {
        "start": 35.44,
        "duration": 3.68,
        "text": "we will soon learn more about specifics"
      },
      {
        "start": 37.52,
        "duration": 4.16,
        "text": "of dac graph frame"
      },
      {
        "start": 39.12,
        "duration": 4.48,
        "text": "based on our killer video graph example"
      },
      {
        "start": 41.68,
        "duration": 3.6,
        "text": "there are various ways you can work with"
      },
      {
        "start": 43.6,
        "duration": 4.24,
        "text": "the dac graph frames"
      },
      {
        "start": 45.28,
        "duration": 4.72,
        "text": "you can use a subset of gremlin to"
      },
      {
        "start": 47.84,
        "duration": 4.719,
        "text": "define a lab graph traversals"
      },
      {
        "start": 50.0,
        "duration": 4.0,
        "text": "there is also a complementary dac graph"
      },
      {
        "start": 52.559,
        "duration": 2.961,
        "text": "frame api"
      },
      {
        "start": 54.0,
        "duration": 4.079,
        "text": "that is primarily used for bulk"
      },
      {
        "start": 55.52,
        "duration": 4.8,
        "text": "mutations you can search for structural"
      },
      {
        "start": 58.079,
        "duration": 3.601,
        "text": "graph patterns using the original spar"
      },
      {
        "start": 60.32,
        "duration": 5.04,
        "text": "graph frame api"
      },
      {
        "start": 61.68,
        "duration": 5.2,
        "text": "finally you can use any other spark api"
      },
      {
        "start": 65.36,
        "duration": 4.56,
        "text": "that may be suitable for your"
      },
      {
        "start": 66.88,
        "duration": 5.84,
        "text": "application that includes spark sql"
      },
      {
        "start": 69.92,
        "duration": 3.84,
        "text": "data frames and spark streaming just to"
      },
      {
        "start": 72.72,
        "duration": 3.12,
        "text": "name a few"
      },
      {
        "start": 73.76,
        "duration": 4.16,
        "text": "when it comes to dec graph frame use"
      },
      {
        "start": 75.84,
        "duration": 5.12,
        "text": "cases there are many"
      },
      {
        "start": 77.92,
        "duration": 5.92,
        "text": "you the versatility and power of this"
      },
      {
        "start": 80.96,
        "duration": 4.32,
        "text": "olap engine of course you can do gremlin"
      },
      {
        "start": 83.84,
        "duration": 3.599,
        "text": "traversals just like"
      },
      {
        "start": 85.28,
        "duration": 4.08,
        "text": "in the other alarm traversal engine"
      },
      {
        "start": 87.439,
        "duration": 3.841,
        "text": "based on the spar graph computer"
      },
      {
        "start": 89.36,
        "duration": 4.16,
        "text": "but these segre frames are unique as"
      },
      {
        "start": 91.28,
        "duration": 3.28,
        "text": "they also support non-gremlin graph data"
      },
      {
        "start": 93.52,
        "duration": 3.919,
        "text": "manipulation"
      },
      {
        "start": 94.56,
        "duration": 5.04,
        "text": "and accessing data directly from spark"
      },
      {
        "start": 97.439,
        "duration": 3.761,
        "text": "as a result you can combine data stored"
      },
      {
        "start": 99.6,
        "duration": 4.32,
        "text": "in dsa graph"
      },
      {
        "start": 101.2,
        "duration": 4.879,
        "text": "with data stored in cassandra with data"
      },
      {
        "start": 103.92,
        "duration": 4.4,
        "text": "stored in the relational database"
      },
      {
        "start": 106.079,
        "duration": 3.841,
        "text": "with data stored in a file with data"
      },
      {
        "start": 108.32,
        "duration": 4.64,
        "text": "coming in a stream"
      },
      {
        "start": 109.92,
        "duration": 5.519,
        "text": "and so forth and so on with this kind of"
      },
      {
        "start": 112.96,
        "duration": 3.68,
        "text": "power there are virtually unlimited"
      },
      {
        "start": 115.439,
        "duration": 3.841,
        "text": "possibilities"
      },
      {
        "start": 116.64,
        "duration": 4.32,
        "text": "for the type of analysis you may need it"
      },
      {
        "start": 119.28,
        "duration": 3.68,
        "text": "is also worth mentioning"
      },
      {
        "start": 120.96,
        "duration": 3.199,
        "text": "that dac graph frame is currently the"
      },
      {
        "start": 122.96,
        "duration": 3.759,
        "text": "most efficient way"
      },
      {
        "start": 124.159,
        "duration": 4.001,
        "text": "to do bulk loading and bulk mutations in"
      },
      {
        "start": 126.719,
        "duration": 4.001,
        "text": "dc graph"
      },
      {
        "start": 128.16,
        "duration": 4.799,
        "text": "if you have an existing graph data set"
      },
      {
        "start": 130.72,
        "duration": 4.56,
        "text": "that you want to load into dsc graph the"
      },
      {
        "start": 132.959,
        "duration": 4.881,
        "text": "ec graph frames is the way to go"
      },
      {
        "start": 135.28,
        "duration": 3.679,
        "text": "let's create our first dac graph frame"
      },
      {
        "start": 137.84,
        "duration": 3.039,
        "text": "in spark shell"
      },
      {
        "start": 138.959,
        "duration": 3.041,
        "text": "to do that we start spark shell by"
      },
      {
        "start": 140.879,
        "duration": 3.761,
        "text": "executing command"
      },
      {
        "start": 142.0,
        "duration": 3.36,
        "text": "dsc spark and then call the dsc graph"
      },
      {
        "start": 144.64,
        "duration": 2.64,
        "text": "method"
      },
      {
        "start": 145.36,
        "duration": 4.0,
        "text": "of the spark session object with the"
      },
      {
        "start": 147.28,
        "duration": 4.48,
        "text": "name of the graph as a parameter"
      },
      {
        "start": 149.36,
        "duration": 3.519,
        "text": "killer video in this case we assign the"
      },
      {
        "start": 151.76,
        "duration": 2.96,
        "text": "result to g"
      },
      {
        "start": 152.879,
        "duration": 3.201,
        "text": "which is an instance of the ac graph"
      },
      {
        "start": 154.72,
        "duration": 3.36,
        "text": "frame as you can see"
      },
      {
        "start": 156.08,
        "duration": 3.12,
        "text": "in the output while it is convenient to"
      },
      {
        "start": 158.08,
        "duration": 3.28,
        "text": "think about"
      },
      {
        "start": 159.2,
        "duration": 4.64,
        "text": "a dac graph frame as simply a"
      },
      {
        "start": 161.36,
        "duration": 2.959,
        "text": "representation of a graph stored in dsc"
      },
      {
        "start": 163.84,
        "duration": 3.2,
        "text": "graph"
      },
      {
        "start": 164.319,
        "duration": 3.521,
        "text": "there is a bit more to it internally in"
      },
      {
        "start": 167.04,
        "duration": 3.68,
        "text": "spark"
      },
      {
        "start": 167.84,
        "duration": 6.0,
        "text": "a dac graph frame is represented by two"
      },
      {
        "start": 170.72,
        "duration": 5.92,
        "text": "virtual tables or data frames"
      },
      {
        "start": 173.84,
        "duration": 4.399,
        "text": "one for vertices and one for edges the"
      },
      {
        "start": 176.64,
        "duration": 4.959,
        "text": "vertex data frame"
      },
      {
        "start": 178.239,
        "duration": 6.481,
        "text": "has columns for vertex id label"
      },
      {
        "start": 181.599,
        "duration": 4.801,
        "text": "and properties the h data frame has"
      },
      {
        "start": 184.72,
        "duration": 3.12,
        "text": "columns for source and destination"
      },
      {
        "start": 186.4,
        "duration": 4.88,
        "text": "vertex ids"
      },
      {
        "start": 187.84,
        "duration": 6.08,
        "text": "edge internal id label and properties"
      },
      {
        "start": 191.28,
        "duration": 5.36,
        "text": "it is important to notice that even so"
      },
      {
        "start": 193.92,
        "duration": 5.12,
        "text": "vertex ids in dc graph can be composed"
      },
      {
        "start": 196.64,
        "duration": 4.64,
        "text": "of values from multiple properties"
      },
      {
        "start": 199.04,
        "duration": 4.64,
        "text": "the dsa graph frame representation"
      },
      {
        "start": 201.28,
        "duration": 3.44,
        "text": "always serializes a vertex id as a"
      },
      {
        "start": 203.68,
        "duration": 3.44,
        "text": "single value"
      },
      {
        "start": 204.72,
        "duration": 3.76,
        "text": "through hashing and concatenation this"
      },
      {
        "start": 207.12,
        "duration": 3.839,
        "text": "is done on purpose"
      },
      {
        "start": 208.48,
        "duration": 5.039,
        "text": "to make the dsc graph frame format fully"
      },
      {
        "start": 210.959,
        "duration": 3.521,
        "text": "compatible with the original spark graph"
      },
      {
        "start": 213.519,
        "duration": 2.881,
        "text": "frame format"
      },
      {
        "start": 214.48,
        "duration": 3.679,
        "text": "so that you can take a full advantage of"
      },
      {
        "start": 216.4,
        "duration": 3.919,
        "text": "various spark apis"
      },
      {
        "start": 218.159,
        "duration": 3.201,
        "text": "in general this id conversion is done"
      },
      {
        "start": 220.319,
        "duration": 4.161,
        "text": "implicitly and"
      },
      {
        "start": 221.36,
        "duration": 3.76,
        "text": "automatically but we will also learn how"
      },
      {
        "start": 224.48,
        "duration": 3.119,
        "text": "to do it"
      },
      {
        "start": 225.12,
        "duration": 3.28,
        "text": "explicitly which will be useful in some"
      },
      {
        "start": 227.599,
        "duration": 2.881,
        "text": "cases"
      },
      {
        "start": 228.4,
        "duration": 3.68,
        "text": "in the context of our kilo video graph"
      },
      {
        "start": 230.48,
        "duration": 4.64,
        "text": "this is how the vertex"
      },
      {
        "start": 232.08,
        "duration": 3.84,
        "text": "table schema looks like g is our dsc"
      },
      {
        "start": 235.12,
        "duration": 2.72,
        "text": "graph frame"
      },
      {
        "start": 235.92,
        "duration": 3.12,
        "text": "we call its method v to get the vertex"
      },
      {
        "start": 237.84,
        "duration": 4.0,
        "text": "data frame"
      },
      {
        "start": 239.04,
        "duration": 3.119,
        "text": "and then data frames matter print schema"
      },
      {
        "start": 241.84,
        "duration": 3.52,
        "text": "to"
      },
      {
        "start": 242.159,
        "duration": 6.64,
        "text": "output the result we see columns id"
      },
      {
        "start": 245.36,
        "duration": 7.36,
        "text": "label user id age gender"
      },
      {
        "start": 248.799,
        "duration": 4.401,
        "text": "genre id name person id movie id and so"
      },
      {
        "start": 252.72,
        "duration": 2.879,
        "text": "forth"
      },
      {
        "start": 253.2,
        "duration": 4.4,
        "text": "the production column is a bit unique as"
      },
      {
        "start": 255.599,
        "duration": 4.081,
        "text": "it corresponds to a multi-property"
      },
      {
        "start": 257.6,
        "duration": 3.039,
        "text": "and its data type is the array of"
      },
      {
        "start": 259.68,
        "duration": 2.88,
        "text": "strings"
      },
      {
        "start": 260.639,
        "duration": 4.321,
        "text": "based on the columns you can see that"
      },
      {
        "start": 262.56,
        "duration": 3.68,
        "text": "this data frame is used for vertices of"
      },
      {
        "start": 264.96,
        "duration": 4.16,
        "text": "different types"
      },
      {
        "start": 266.24,
        "duration": 3.679,
        "text": "in our case users movies people and"
      },
      {
        "start": 269.12,
        "duration": 3.04,
        "text": "genres"
      },
      {
        "start": 269.919,
        "duration": 3.361,
        "text": "using data frames meta show we can take"
      },
      {
        "start": 272.16,
        "duration": 4.8,
        "text": "a look at the actual"
      },
      {
        "start": 273.28,
        "duration": 7.68,
        "text": "column values in the first five rows"
      },
      {
        "start": 276.96,
        "duration": 6.88,
        "text": "we have rows corresponding to user u185"
      },
      {
        "start": 280.96,
        "duration": 3.28,
        "text": "genre adventure person johnny depp and"
      },
      {
        "start": 283.84,
        "duration": 3.44,
        "text": "two"
      },
      {
        "start": 284.24,
        "duration": 5.6,
        "text": "alice in wonderland movies similarly"
      },
      {
        "start": 287.28,
        "duration": 4.08,
        "text": "we can output the age data frame schema"
      },
      {
        "start": 289.84,
        "duration": 3.52,
        "text": "for the kili video graph"
      },
      {
        "start": 291.36,
        "duration": 4.8,
        "text": "it does look simpler because we only"
      },
      {
        "start": 293.36,
        "duration": 5.44,
        "text": "have one edge property called rating"
      },
      {
        "start": 296.16,
        "duration": 4.479,
        "text": "and it is of type int and you may"
      },
      {
        "start": 298.8,
        "duration": 2.56,
        "text": "remember that source and destination are"
      },
      {
        "start": 300.639,
        "duration": 3.201,
        "text": "columns"
      },
      {
        "start": 301.36,
        "duration": 3.679,
        "text": "that store age source and destination"
      },
      {
        "start": 303.84,
        "duration": 4.16,
        "text": "vertex ids"
      },
      {
        "start": 305.039,
        "duration": 5.041,
        "text": "an id is a column that stores hids that"
      },
      {
        "start": 308.0,
        "duration": 4.32,
        "text": "are generated and used internally"
      },
      {
        "start": 310.08,
        "duration": 3.52,
        "text": "by dsc graph here are some concrete"
      },
      {
        "start": 312.32,
        "duration": 3.52,
        "text": "values to look at"
      },
      {
        "start": 313.6,
        "duration": 4.08,
        "text": "besides the label and rating there is"
      },
      {
        "start": 315.84,
        "duration": 4.0,
        "text": "not much for us to comprehend"
      },
      {
        "start": 317.68,
        "duration": 4.48,
        "text": "finally we conclude this presentation"
      },
      {
        "start": 319.84,
        "duration": 5.44,
        "text": "with the summary of the ec graph frame"
      },
      {
        "start": 322.16,
        "duration": 6.56,
        "text": "apis that we cover in more detail"
      },
      {
        "start": 325.28,
        "duration": 6.24,
        "text": "in subsequent videos first we have"
      },
      {
        "start": 328.72,
        "duration": 4.88,
        "text": "gremlin api to define gremlin traversals"
      },
      {
        "start": 331.52,
        "duration": 5.44,
        "text": "starting with either method v"
      },
      {
        "start": 333.6,
        "duration": 3.76,
        "text": "or method e followed by traversal steps"
      },
      {
        "start": 336.96,
        "duration": 3.76,
        "text": "like"
      },
      {
        "start": 337.36,
        "duration": 3.839,
        "text": "in out count and so on we assume that"
      },
      {
        "start": 340.72,
        "duration": 2.4,
        "text": "you are"
      },
      {
        "start": 341.199,
        "duration": 3.041,
        "text": "already familiar with the gremlin"
      },
      {
        "start": 343.12,
        "duration": 4.0,
        "text": "traversal language"
      },
      {
        "start": 344.24,
        "duration": 4.64,
        "text": "second there is spar graph frame api"
      },
      {
        "start": 347.12,
        "duration": 3.84,
        "text": "that among other things"
      },
      {
        "start": 348.88,
        "duration": 3.52,
        "text": "has some interesting structural pattern"
      },
      {
        "start": 350.96,
        "duration": 3.679,
        "text": "matching capabilities"
      },
      {
        "start": 352.4,
        "duration": 3.919,
        "text": "in scholar the esc graph frame is"
      },
      {
        "start": 354.639,
        "duration": 5.12,
        "text": "converted to spar graph frame"
      },
      {
        "start": 356.319,
        "duration": 6.88,
        "text": "implicitly explicit conversion is done"
      },
      {
        "start": 359.759,
        "duration": 5.28,
        "text": "using the gf method third we have"
      },
      {
        "start": 363.199,
        "duration": 3.12,
        "text": "very efficient methods for bulk"
      },
      {
        "start": 365.039,
        "duration": 4.321,
        "text": "mutations"
      },
      {
        "start": 366.319,
        "duration": 3.761,
        "text": "we can insert update and delete graph"
      },
      {
        "start": 369.36,
        "duration": 3.6,
        "text": "elements"
      },
      {
        "start": 370.08,
        "duration": 5.04,
        "text": "with those and last but not least we"
      },
      {
        "start": 372.96,
        "duration": 4.64,
        "text": "have the data persistent methods"
      },
      {
        "start": 375.12,
        "duration": 3.6,
        "text": "cache and persist which you may already"
      },
      {
        "start": 377.6,
        "duration": 2.96,
        "text": "be familiar with"
      },
      {
        "start": 378.72,
        "duration": 9.28,
        "text": "since they have the same purpose as"
      },
      {
        "start": 380.56,
        "duration": 7.44,
        "text": "similar methods available in spark"
      }
    ],
    "error": null,
    "error_type": null
  },
  "collected_at": "2025-12-15T23:04:17.166403+00:00"
}