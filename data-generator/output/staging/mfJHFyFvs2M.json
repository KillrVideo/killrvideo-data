{
  "video_id": "mfJHFyFvs2M",
  "title": "DS201.07 Ring | Foundations of Apache Cassandra",
  "description": "#DataStaxAcademy #DS201\nDS201.07 RING\nIn this unit we will learn about ring, also known as the Apache Cassandra cluster. It is the heart of Apache Cassandra. Since Apache Cassandra is a clustering system, it is an important concept to understand.\n\nLEARN FOR FREE at https://academy.datastax.com -- access all the FREE complete courses, tutorials, and hands-on exercises.\n\nASK QUESTIONS at https://community.datastax.com -- where experts from DataStax & the Apache Cassandra community share their expertise everyday.",
  "published_at": "2020-08-06T03:59:59Z",
  "thumbnail": "https://i.ytimg.com/vi/mfJHFyFvs2M/maxresdefault.jpg",
  "channel_title": "DataStax Developers",
  "channel_id": "UCAIQY251avaMv7bBv5PCo-A",
  "tags": [
    "cassandra",
    "datastax",
    "tutorial",
    "apache_cassandra"
  ],
  "url": "https://www.youtube.com/watch?v=mfJHFyFvs2M",
  "transcript": {
    "available": true,
    "language": "Chinese",
    "language_code": "zh",
    "is_generated": false,
    "text": "DS201.7: 哈希环(Ring) 希望你已经理解了一个独立的节点 并且准备好学习Cassandra的核心内容——哈希环 也称为Apache Cassandra集群(Cluster) 因为Apache Cassandra是一个集群式的系统(Clustering System) 这是一个需要理解的很重要的概念 你可以在单个节点上运行Apache Cassandra  但你干嘛要这样呢 如果你这样做的话 就会错过所有Cassandra作为集群所能做的超酷的事情 为什么无论如何你不会只使用一个单独的节点呢？ 如果这样做 你就得用一个相当大的机器来运行这个小小的节点 这也意味着花费更多的钱在设备上 从而能够处理这些负载 我们刚说的就是水平伸缩(Horizontal Scaling) 你看这个单独的节点 它刚刚好可以处理当前的负载量 无论读取还是写入 一切都很好 但随着负载量的增加 我们可怜的节点在重压下逐渐无力应对 当这种情况发生时 系统会崩溃 我相信你原来也遇到过这种情况 这感觉并不好 所以Apache Cassandra是如何处理这种情况的呢？ 我们只需要增加更多的节点 这很简单 对吧 如果你需要更多的处理能力 那就添加更多的节点 在云环境中 最酷的是你只需要在更多的服务器上运行 就能处理额外的负载量 话说到这儿 Apache Cassandra集群到底是怎么运行的呢？ 当一个数据被写入集群时 它应该被储存在一个指定的节点 具体的过程是什么呢？ 让我来给你举个例子 假设我有一条分区键为59的数据 厉害的是 你可以将这条数据写入集群中的任何一个节点 这个被写入数据的节点就会被称为协调节点(Coordinator Node) 协调节点的任务是 根据收到的数据的分区 将其发给存储相应分区的节点 也就是负责那一部分数据的节点 这里提一句 在集群中所有节点都可以扮演协调节点的角色 但它到底是如何工作的呢？ 协调节点是如何知道数据应该去到哪一个节点呢？ 事实上 每一个节点都负责一个范围的数据 这个范围被称为令牌区间(Token Range) 协调节点知道每个节点所负责的数据范围 所以可以将数据发送到正确的节点 协调节点会从客户端获取数据 然后将数据发送到正确的节点 接着协调节点会向客户端返回一条确认信息(Acknowledgement) 那么你可以在一个集群中储存多少数据呢？ 绝对很多 我和你打赌 在之前的案例中 我们将集群中节点令牌的范围设为100 这只是处于示范的目的 从而让你更好的理解 很多数据是并不能被放入令牌范围只有100的集群中 实际上 令牌范围会从-2^63开始 整整绕一圈直到2^63-1 这样的范围应该足以储存所有你想储存的数据了 这是一个十分十分巨大的数字 令牌是如何在哈希环中分布的呢？ 这就需要运用到分区算法(partitioner)了 分区算法决定了在哈希环中会如何分布数据 如果这个部分没搞好 你的集群中会产生热点(Hotspot) 数据不会被均匀地分布在集群中 有些节点会超负荷\n而其他节点则会因无所事事而感到高兴 这并不好 因为最终节点会爆雷 这样大家都不会开心 面对这种情况的最佳操作方法就是使用正确的分区算法 Murmur3或MD5会在哈希环中对数据进行一个很好的随机分布 而且是平均分布的  顺带一提这是默认的情况 当我们谈谈当节点加入集群时会发生什么 这是集群操作中的一件很酷的事情 什么让它变得很酷呢？ 零宕机时间 当新节点加入时 集群依然正常运转 所以当节点加入哈希环时到底发生了什么呢？ 首先它会和种子节点(Seed node)用Gossip协议进行沟通 就像小声喊一句：“嘿！我是新来的 我需要知道些什么？” 其他节点会计算新来的节点应该被放在哈希环哪个位置 这可以是手动的或自动的 然后其他节点会将数据串流到新的节点 每个节点有4个状态 Joining、Leaving、Up和Down \n（加入中、准备离开、正常工作、出现故障） 在Joining阶段 节点已经在接收数据 然而它并没有完全加入集群 所以并没有准备好被读取 非常棒的是 新节点的加入过程中 数据库一直是在线状态 \n没有宕机时间 当你的数据在集群中快速流动时 你的驱动程序就可以大有用武之地了 当驱动程序连接到Apache Cassandra集群时 它参与了这些数据的交换 当驱动程序连接时 它会获取细节信息 了解当前的令牌区间 并将信息储存到本地环境中 然后驱动程序会知道不同令牌区间分别属于哪个节点和副本 当我们谈到令牌区间 为什么说让客户端知道集群状态十分重要呢？ 驱动程序很酷的一点是 它是能知道令牌区间的 驱动程序中其中的一个策略就是TokenAwarePolicy 呵呵 这很酷 所以当数据进入驱动程序时  驱动程序会说 哦 这个节点负责这一个令牌区间 那我就将数据直接发送到这个节点 这样的好处是 协调节点就不需要介入这个过程了 这样会使系统更加高效 除了TokenAwarePolicy以外还有其他的一些策略 如RoundRobinPolicy 这个策略就得依赖于协调节点了 还有DCAwareRoundRobinPolicy 它是用来确保数据被储存在本地数据中心的 Apache Cassandra是能感知拓扑结构(Topology-aware)的 因此你的驱动程序也应该能做到这点 那这跟扩展(Scaling)有什么关系呢？ 当我们回到单独服务器的环境中 一个单独的服务器可能会过载 这向来不是好事 现在 你需要做出选择 你可以用更大更好的服务器 但这意味着会有宕机时间 因为你得要卸下原有的数据 并且将其转移到更大的服务器 或者你可以选择Apache Cassandra最擅长的方式 随着负载持续增加 你可以逐步添加更多的节点 让我们看看这个图表 当你添加更多的节点时 你会获取更大的处理能力 这张图显示了使用了“读-修改-写(Read-Modify-Write)负载”的测试结果 这个结果和“绝大部分都是读取操作(Read-mostly)的负载”的测试结果 以及“读写混合平衡(Balanced Read/Write Mix)的负载”的测试结果都一样 以上的任何一个都显示出 只要向集群添加节点 Apache Cassandra都会有同样的伸缩效果 总的来说 添加更多的节点 得到更强的处理能力 这超棒 能在线添加更多节点？没有宕机时间？  哇哦！ 我们总会对比水平伸缩(Horizontal Scaling)\n和垂直伸缩(Vertical Scaling) 但很重要的是  垂直伸缩是可行的方案 你可以使用比现在配置更好的设备来增加性能 这是可行的 但水平伸缩是这里的关键 你总是想要有高效率对吧？ 这里你可以看到 两个节点可以独立处理很多工作 但如果你将节点数翻倍 你可以获得两倍的性能 以此类推 每当你将节点数量翻倍时 你的集群性能也在翻倍 无论是有十个、百个还是千个节点的生产集群 节点的数量旨在匹配其承受的负载 Apache Cassandra很赞的一个特性是 你可以根据需求来进行扩容 当然 根据需求缩减容量也是可以的 你可以在负载增多时 对集群临时进行扩容 例如 在黑色星期五期间（类似“双十一”的购物季） 如果之后没有这么大的需求 你之后可以恢复原来集群规模  长期来看 这会节省你的时间和金钱",
    "segments": [
      {
        "start": 1.217,
        "duration": 5.346,
        "text": "DS201.7: 哈希环(Ring)"
      },
      {
        "start": 6.73,
        "duration": 2.821,
        "text": "希望你已经理解了一个独立的节点"
      },
      {
        "start": 9.612,
        "duration": 3.149,
        "text": "并且准备好学习Cassandra的核心内容——哈希环"
      },
      {
        "start": 12.761,
        "duration": 2.97,
        "text": "也称为Apache Cassandra集群(Cluster)"
      },
      {
        "start": 15.731,
        "duration": 2.557,
        "text": "因为Apache Cassandra是一个集群式的系统(Clustering System)"
      },
      {
        "start": 18.288,
        "duration": 2.19,
        "text": "这是一个需要理解的很重要的概念"
      },
      {
        "start": 20.478,
        "duration": 2.317,
        "text": "你可以在单个节点上运行Apache Cassandra "
      },
      {
        "start": 22.795,
        "duration": 1.205,
        "text": "但你干嘛要这样呢"
      },
      {
        "start": 24.0,
        "duration": 4.796,
        "text": "如果你这样做的话 就会错过所有Cassandra作为集群所能做的超酷的事情"
      },
      {
        "start": 28.796,
        "duration": 2.283,
        "text": "为什么无论如何你不会只使用一个单独的节点呢？"
      },
      {
        "start": 31.079,
        "duration": 4.14,
        "text": "如果这样做 你就得用一个相当大的机器来运行这个小小的节点"
      },
      {
        "start": 35.219,
        "duration": 3.781,
        "text": "这也意味着花费更多的钱在设备上 从而能够处理这些负载"
      },
      {
        "start": 39.0,
        "duration": 2.691,
        "text": "我们刚说的就是水平伸缩(Horizontal Scaling)"
      },
      {
        "start": 41.691,
        "duration": 3.11,
        "text": "你看这个单独的节点"
      },
      {
        "start": 44.801,
        "duration": 2.081,
        "text": "它刚刚好可以处理当前的负载量"
      },
      {
        "start": 46.882,
        "duration": 2.608,
        "text": "无论读取还是写入 一切都很好"
      },
      {
        "start": 49.49,
        "duration": 4.286,
        "text": "但随着负载量的增加 我们可怜的节点在重压下逐渐无力应对"
      },
      {
        "start": 53.776,
        "duration": 2.79,
        "text": "当这种情况发生时 系统会崩溃"
      },
      {
        "start": 56.566,
        "duration": 2.768,
        "text": "我相信你原来也遇到过这种情况"
      },
      {
        "start": 59.334,
        "duration": 1.12,
        "text": "这感觉并不好"
      },
      {
        "start": 60.454,
        "duration": 3.6,
        "text": "所以Apache Cassandra是如何处理这种情况的呢？"
      },
      {
        "start": 64.054,
        "duration": 2.294,
        "text": "我们只需要增加更多的节点"
      },
      {
        "start": 66.348,
        "duration": 1.148,
        "text": "这很简单 对吧"
      },
      {
        "start": 67.496,
        "duration": 2.269,
        "text": "如果你需要更多的处理能力 那就添加更多的节点"
      },
      {
        "start": 69.765,
        "duration": 5.107,
        "text": "在云环境中 最酷的是你只需要在更多的服务器上运行 就能处理额外的负载量"
      },
      {
        "start": 74.872,
        "duration": 2.827,
        "text": "话说到这儿 Apache Cassandra集群到底是怎么运行的呢？"
      },
      {
        "start": 77.699,
        "duration": 4.326,
        "text": "当一个数据被写入集群时 它应该被储存在一个指定的节点"
      },
      {
        "start": 82.025,
        "duration": 1.687,
        "text": "具体的过程是什么呢？"
      },
      {
        "start": 83.712,
        "duration": 2.0,
        "text": "让我来给你举个例子"
      },
      {
        "start": 85.712,
        "duration": 3.419,
        "text": "假设我有一条分区键为59的数据"
      },
      {
        "start": 89.131,
        "duration": 4.059,
        "text": "厉害的是 你可以将这条数据写入集群中的任何一个节点"
      },
      {
        "start": 93.19,
        "duration": 2.503,
        "text": "这个被写入数据的节点就会被称为协调节点(Coordinator Node)"
      },
      {
        "start": 95.693,
        "duration": 1.784,
        "text": "协调节点的任务是"
      },
      {
        "start": 97.477,
        "duration": 3.1,
        "text": "根据收到的数据的分区 将其发给存储相应分区的节点"
      },
      {
        "start": 100.577,
        "duration": 1.975,
        "text": "也就是负责那一部分数据的节点"
      },
      {
        "start": 102.552,
        "duration": 1.661,
        "text": "这里提一句"
      },
      {
        "start": 104.213,
        "duration": 1.951,
        "text": "在集群中所有节点都可以扮演协调节点的角色"
      },
      {
        "start": 106.164,
        "duration": 1.914,
        "text": "但它到底是如何工作的呢？"
      },
      {
        "start": 108.078,
        "duration": 2.955,
        "text": "协调节点是如何知道数据应该去到哪一个节点呢？"
      },
      {
        "start": 111.033,
        "duration": 3.818,
        "text": "事实上 每一个节点都负责一个范围的数据"
      },
      {
        "start": 114.851,
        "duration": 2.0,
        "text": "这个范围被称为令牌区间(Token Range)"
      },
      {
        "start": 116.851,
        "duration": 5.431,
        "text": "协调节点知道每个节点所负责的数据范围 所以可以将数据发送到正确的节点"
      },
      {
        "start": 122.282,
        "duration": 2.449,
        "text": "协调节点会从客户端获取数据"
      },
      {
        "start": 124.731,
        "duration": 1.91,
        "text": "然后将数据发送到正确的节点"
      },
      {
        "start": 126.641,
        "duration": 3.467,
        "text": "接着协调节点会向客户端返回一条确认信息(Acknowledgement)"
      },
      {
        "start": 130.108,
        "duration": 2.939,
        "text": "那么你可以在一个集群中储存多少数据呢？"
      },
      {
        "start": 133.047,
        "duration": 1.328,
        "text": "绝对很多 我和你打赌"
      },
      {
        "start": 134.375,
        "duration": 3.814,
        "text": "在之前的案例中 我们将集群中节点令牌的范围设为100"
      },
      {
        "start": 138.189,
        "duration": 4.568,
        "text": "这只是处于示范的目的 从而让你更好的理解"
      },
      {
        "start": 142.757,
        "duration": 2.79,
        "text": "很多数据是并不能被放入令牌范围只有100的集群中"
      },
      {
        "start": 145.547,
        "duration": 8.592,
        "text": "实际上 令牌范围会从-2^63开始 整整绕一圈直到2^63-1"
      },
      {
        "start": 154.139,
        "duration": 4.532,
        "text": "这样的范围应该足以储存所有你想储存的数据了"
      },
      {
        "start": 158.671,
        "duration": 3.229,
        "text": "这是一个十分十分巨大的数字"
      },
      {
        "start": 162.665,
        "duration": 2.934,
        "text": "令牌是如何在哈希环中分布的呢？"
      },
      {
        "start": 165.599,
        "duration": 2.0,
        "text": "这就需要运用到分区算法(partitioner)了"
      },
      {
        "start": 167.599,
        "duration": 3.652,
        "text": "分区算法决定了在哈希环中会如何分布数据"
      },
      {
        "start": 171.251,
        "duration": 3.455,
        "text": "如果这个部分没搞好 你的集群中会产生热点(Hotspot)"
      },
      {
        "start": 174.706,
        "duration": 1.925,
        "text": "数据不会被均匀地分布在集群中"
      },
      {
        "start": 176.631,
        "duration": 4.169,
        "text": "有些节点会超负荷\n而其他节点则会因无所事事而感到高兴"
      },
      {
        "start": 180.8,
        "duration": 1.497,
        "text": "这并不好"
      },
      {
        "start": 182.297,
        "duration": 3.212,
        "text": "因为最终节点会爆雷 这样大家都不会开心"
      },
      {
        "start": 185.509,
        "duration": 4.412,
        "text": "面对这种情况的最佳操作方法就是使用正确的分区算法"
      },
      {
        "start": 189.921,
        "duration": 6.31,
        "text": "Murmur3或MD5会在哈希环中对数据进行一个很好的随机分布"
      },
      {
        "start": 196.231,
        "duration": 1.569,
        "text": "而且是平均分布的 "
      },
      {
        "start": 197.8,
        "duration": 2.0,
        "text": "顺带一提这是默认的情况"
      },
      {
        "start": 201.584,
        "duration": 2.665,
        "text": "当我们谈谈当节点加入集群时会发生什么"
      },
      {
        "start": 204.249,
        "duration": 3.257,
        "text": "这是集群操作中的一件很酷的事情"
      },
      {
        "start": 207.506,
        "duration": 1.316,
        "text": "什么让它变得很酷呢？"
      },
      {
        "start": 208.822,
        "duration": 1.048,
        "text": "零宕机时间"
      },
      {
        "start": 209.87,
        "duration": 3.13,
        "text": "当新节点加入时 集群依然正常运转"
      },
      {
        "start": 213.0,
        "duration": 3.814,
        "text": "所以当节点加入哈希环时到底发生了什么呢？"
      },
      {
        "start": 216.814,
        "duration": 3.563,
        "text": "首先它会和种子节点(Seed node)用Gossip协议进行沟通"
      },
      {
        "start": 220.377,
        "duration": 4.514,
        "text": "就像小声喊一句：“嘿！我是新来的 我需要知道些什么？”"
      },
      {
        "start": 224.891,
        "duration": 3.23,
        "text": "其他节点会计算新来的节点应该被放在哈希环哪个位置"
      },
      {
        "start": 228.121,
        "duration": 1.879,
        "text": "这可以是手动的或自动的"
      },
      {
        "start": 230.0,
        "duration": 3.159,
        "text": "然后其他节点会将数据串流到新的节点"
      },
      {
        "start": 233.159,
        "duration": 1.883,
        "text": "每个节点有4个状态"
      },
      {
        "start": 235.042,
        "duration": 3.796,
        "text": "Joining、Leaving、Up和Down \n（加入中、准备离开、正常工作、出现故障）"
      },
      {
        "start": 238.838,
        "duration": 3.67,
        "text": "在Joining阶段 节点已经在接收数据"
      },
      {
        "start": 242.508,
        "duration": 2.79,
        "text": "然而它并没有完全加入集群 所以并没有准备好被读取"
      },
      {
        "start": 245.298,
        "duration": 1.252,
        "text": "非常棒的是"
      },
      {
        "start": 246.55,
        "duration": 3.721,
        "text": "新节点的加入过程中 数据库一直是在线状态 \n没有宕机时间"
      },
      {
        "start": 250.881,
        "duration": 5.764,
        "text": "当你的数据在集群中快速流动时 你的驱动程序就可以大有用武之地了"
      },
      {
        "start": 256.645,
        "duration": 2.956,
        "text": "当驱动程序连接到Apache Cassandra集群时"
      },
      {
        "start": 259.601,
        "duration": 2.69,
        "text": "它参与了这些数据的交换"
      },
      {
        "start": 262.291,
        "duration": 2.701,
        "text": "当驱动程序连接时 它会获取细节信息"
      },
      {
        "start": 264.992,
        "duration": 3.861,
        "text": "了解当前的令牌区间 并将信息储存到本地环境中"
      },
      {
        "start": 268.853,
        "duration": 4.654,
        "text": "然后驱动程序会知道不同令牌区间分别属于哪个节点和副本"
      },
      {
        "start": 273.507,
        "duration": 4.886,
        "text": "当我们谈到令牌区间 为什么说让客户端知道集群状态十分重要呢？"
      },
      {
        "start": 278.393,
        "duration": 4.024,
        "text": "驱动程序很酷的一点是 它是能知道令牌区间的"
      },
      {
        "start": 282.417,
        "duration": 3.139,
        "text": "驱动程序中其中的一个策略就是TokenAwarePolicy"
      },
      {
        "start": 285.556,
        "duration": 1.425,
        "text": "呵呵 这很酷"
      },
      {
        "start": 286.981,
        "duration": 2.225,
        "text": "所以当数据进入驱动程序时 "
      },
      {
        "start": 289.206,
        "duration": 5.81,
        "text": "驱动程序会说 哦 这个节点负责这一个令牌区间 那我就将数据直接发送到这个节点"
      },
      {
        "start": 295.016,
        "duration": 3.994,
        "text": "这样的好处是 协调节点就不需要介入这个过程了"
      },
      {
        "start": 299.01,
        "duration": 2.24,
        "text": "这样会使系统更加高效"
      },
      {
        "start": 301.25,
        "duration": 1.968,
        "text": "除了TokenAwarePolicy以外还有其他的一些策略"
      },
      {
        "start": 303.218,
        "duration": 1.304,
        "text": "如RoundRobinPolicy"
      },
      {
        "start": 304.522,
        "duration": 1.825,
        "text": "这个策略就得依赖于协调节点了"
      },
      {
        "start": 306.347,
        "duration": 2.997,
        "text": "还有DCAwareRoundRobinPolicy"
      },
      {
        "start": 309.344,
        "duration": 3.348,
        "text": "它是用来确保数据被储存在本地数据中心的"
      },
      {
        "start": 312.692,
        "duration": 2.429,
        "text": "Apache Cassandra是能感知拓扑结构(Topology-aware)的"
      },
      {
        "start": 315.121,
        "duration": 1.966,
        "text": "因此你的驱动程序也应该能做到这点"
      },
      {
        "start": 317.087,
        "duration": 2.243,
        "text": "那这跟扩展(Scaling)有什么关系呢？"
      },
      {
        "start": 319.33,
        "duration": 2.011,
        "text": "当我们回到单独服务器的环境中"
      },
      {
        "start": 321.341,
        "duration": 4.298,
        "text": "一个单独的服务器可能会过载 这向来不是好事"
      },
      {
        "start": 325.639,
        "duration": 1.861,
        "text": "现在 你需要做出选择"
      },
      {
        "start": 327.5,
        "duration": 3.385,
        "text": "你可以用更大更好的服务器 但这意味着会有宕机时间"
      },
      {
        "start": 330.885,
        "duration": 3.355,
        "text": "因为你得要卸下原有的数据 并且将其转移到更大的服务器"
      },
      {
        "start": 334.24,
        "duration": 3.755,
        "text": "或者你可以选择Apache Cassandra最擅长的方式"
      },
      {
        "start": 337.995,
        "duration": 2.63,
        "text": "随着负载持续增加 你可以逐步添加更多的节点"
      },
      {
        "start": 340.625,
        "duration": 2.0,
        "text": "让我们看看这个图表"
      },
      {
        "start": 342.625,
        "duration": 2.375,
        "text": "当你添加更多的节点时 你会获取更大的处理能力"
      },
      {
        "start": 345.0,
        "duration": 2.258,
        "text": "这张图显示了使用了“读-修改-写(Read-Modify-Write)负载”的测试结果"
      },
      {
        "start": 347.258,
        "duration": 2.575,
        "text": "这个结果和“绝大部分都是读取操作(Read-mostly)的负载”的测试结果"
      },
      {
        "start": 349.833,
        "duration": 1.807,
        "text": "以及“读写混合平衡(Balanced Read/Write Mix)的负载”的测试结果都一样"
      },
      {
        "start": 351.64,
        "duration": 3.298,
        "text": "以上的任何一个都显示出 只要向集群添加节点"
      },
      {
        "start": 354.938,
        "duration": 4.371,
        "text": "Apache Cassandra都会有同样的伸缩效果"
      },
      {
        "start": 359.309,
        "duration": 5.425,
        "text": "总的来说 添加更多的节点 得到更强的处理能力 这超棒"
      },
      {
        "start": 364.734,
        "duration": 4.266,
        "text": "能在线添加更多节点？没有宕机时间？ "
      },
      {
        "start": 369.0,
        "duration": 1.375,
        "text": "哇哦！"
      },
      {
        "start": 370.375,
        "duration": 4.477,
        "text": "我们总会对比水平伸缩(Horizontal Scaling)\n和垂直伸缩(Vertical Scaling)"
      },
      {
        "start": 374.852,
        "duration": 1.479,
        "text": "但很重要的是 "
      },
      {
        "start": 376.331,
        "duration": 2.0,
        "text": "垂直伸缩是可行的方案"
      },
      {
        "start": 378.331,
        "duration": 2.807,
        "text": "你可以使用比现在配置更好的设备来增加性能"
      },
      {
        "start": 381.138,
        "duration": 1.091,
        "text": "这是可行的"
      },
      {
        "start": 382.229,
        "duration": 2.913,
        "text": "但水平伸缩是这里的关键"
      },
      {
        "start": 385.142,
        "duration": 2.215,
        "text": "你总是想要有高效率对吧？"
      },
      {
        "start": 387.357,
        "duration": 4.521,
        "text": "这里你可以看到 两个节点可以独立处理很多工作"
      },
      {
        "start": 391.878,
        "duration": 5.079,
        "text": "但如果你将节点数翻倍 你可以获得两倍的性能 以此类推"
      },
      {
        "start": 396.957,
        "duration": 3.419,
        "text": "每当你将节点数量翻倍时 你的集群性能也在翻倍"
      },
      {
        "start": 400.376,
        "duration": 6.718,
        "text": "无论是有十个、百个还是千个节点的生产集群 节点的数量旨在匹配其承受的负载"
      },
      {
        "start": 407.094,
        "duration": 4.622,
        "text": "Apache Cassandra很赞的一个特性是 你可以根据需求来进行扩容"
      },
      {
        "start": 411.716,
        "duration": 3.187,
        "text": "当然 根据需求缩减容量也是可以的"
      },
      {
        "start": 414.903,
        "duration": 3.528,
        "text": "你可以在负载增多时 对集群临时进行扩容"
      },
      {
        "start": 418.431,
        "duration": 1.896,
        "text": "例如 在黑色星期五期间（类似“双十一”的购物季）"
      },
      {
        "start": 420.327,
        "duration": 4.242,
        "text": "如果之后没有这么大的需求 你之后可以恢复原来集群规模 "
      },
      {
        "start": 424.569,
        "duration": 3.181,
        "text": "长期来看 这会节省你的时间和金钱"
      }
    ],
    "error": null,
    "error_type": null
  },
  "collected_at": "2025-12-16T02:05:45.309449+00:00"
}